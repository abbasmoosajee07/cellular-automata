<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGL Triangle Grid</title>
<style>
body { 
    margin:0; 
    padding:0; 
    overflow:hidden; 
    background:#1a1a2e; 
    font-family:sans-serif; 
}
canvas { 
    display:block; 
    cursor:crosshair; 
}
#controls {
    position:absolute; 
    top:20px; 
    left:20px; 
    background:rgba(255,255,255,0.95); 
    padding:15px; 
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.2); 
    max-width:280px;
}
button { 
    margin-right:5px; 
    margin-bottom:5px; 
    background:#4a6fa5; 
    color:white; 
    border:none; 
    padding:8px 15px; 
    border-radius:4px; 
    cursor:pointer; 
}
button:hover { 
    background:#3a5a8a; 
}
</style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<div id="controls">
    <button id="fillAll">Fill All</button>
    <button id="clear">Clear</button>
    <input type="color" id="colorPicker" value="#4a90e2">
</div>

<script>
class WebGLTriangleGrid {
    constructor(canvas, cellSize=60, cols=30, rows=25) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl');
        if(!this.gl){ alert("WebGL not supported"); return; }

        this.cellSize = cellSize;
        this.gridCols = cols;
        this.gridRows = rows;
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;

        this.currentColor = [0.29,0.56,0.89,1]; // default
        this.coloredTriangles = {}; // key="col,row"

        this.initShaders();
        this.initBuffers();
        this.setupEvents();
        this.render();
    }

    initShaders(){
        const gl = this.gl;
        const vertSrc = `
            attribute vec2 aPos;
            uniform vec2 uOffset;
            uniform float uZoom;
            uniform vec2 uResolution;
            void main(){
                vec2 pos = (aPos + uOffset) * uZoom;
                vec2 clip = pos / uResolution * 2.0 - 1.0;
                clip.y = -clip.y;
                gl_Position = vec4(clip,0,1);
            }
        `;
        const fragSrc = `
            precision mediump float;
            uniform vec4 uColor;
            void main(){ gl_FragColor = uColor; }
        `;
        const vert = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vert, vertSrc); gl.compileShader(vert);
        const frag = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(frag, fragSrc); gl.compileShader(frag);
        const program = gl.createProgram();
        gl.attachShader(program, vert); gl.attachShader(program, frag);
        gl.linkProgram(program);
        this.program = program;
        this.aPos = gl.getAttribLocation(program, 'aPos');
        this.uColor = gl.getUniformLocation(program,'uColor');
        this.uOffset = gl.getUniformLocation(program,'uOffset');
        this.uZoom = gl.getUniformLocation(program,'uZoom');
        this.uResolution = gl.getUniformLocation(program,'uResolution');
        gl.useProgram(program);
    }

    initBuffers(){
        const gl = this.gl;
        this.vertexBuffer = gl.createBuffer();
    }

    drawTriangle(col,row,color){
        const gl = this.gl;
        const s = this.cellSize;
        const h = s*Math.sqrt(3)/2;
        const xOffset = col*s/2;
        const yOffset = row*h;
        const orientation = (col+row)%2;

        let vertices;
        if(orientation===0){
            vertices = new Float32Array([
                xOffset, yOffset+h,
                xOffset+s/2, yOffset,
                xOffset+s, yOffset+h
            ]);
        }else{
            vertices = new Float32Array([
                xOffset, yOffset,
                xOffset+s/2, yOffset+h,
                xOffset+s, yOffset
            ]);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(this.aPos,2,gl.FLOAT,false,0,0);
        gl.enableVertexAttribArray(this.aPos);
        gl.uniform4fv(this.uColor,color);
        gl.drawArrays(gl.TRIANGLES,0,3);
    }

    render(){
        const gl = this.gl;
        gl.viewport(0,0,this.canvas.width,this.canvas.height);
        gl.clearColor(0.1,0.1,0.18,1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(this.uOffset,this.offsetX,this.offsetY);
        gl.uniform1f(this.uZoom,this.zoom);
        gl.uniform2f(this.uResolution,this.canvas.width,this.canvas.height);

        for(let r=0;r<this.gridRows;r++){
            for(let c=0;c<this.gridCols;c++){
                const key=`${c},${r}`;
                const color = this.coloredTriangles[key]||[0.15,0.15,0.25,1];
                this.drawTriangle(c,r,color);
            }
        }
    }

    screenToCell(x,y){
        const s=this.cellSize;
        const h=s*Math.sqrt(3)/2;
        const worldX=(x/this.zoom)-this.offsetX;
        const worldY=(y/this.zoom)-this.offsetY;
        const row=Math.floor(worldY/h);
        const col=Math.floor(worldX/(s/2));
        return [col,row];
    }

    setCellColor(col,row,color){
        if(col<0||row<0||col>=this.gridCols||row>=this.gridRows) return;
        this.coloredTriangles[`${col},${row}`]=color;
        this.render();
    }

    setupEvents(){
        const canvas = this.canvas;
        let dragging=false,lastX=0,lastY=0;
        canvas.addEventListener('mousedown',e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
        canvas.addEventListener('mouseup',e=>{ dragging=false; });
        canvas.addEventListener('mousemove',e=>{
            if(dragging){
                this.offsetX += (e.clientX-lastX)/this.zoom;
                this.offsetY += (e.clientY-lastY)/this.zoom;
                lastX=e.clientX; lastY=e.clientY;
                this.render();
            }
        });
        canvas.addEventListener('wheel',e=>{
            e.preventDefault();
            const factor = e.deltaY>0?0.9:1.1;
            this.zoom*=factor;
            this.zoom=Math.min(3,Math.max(0.1,this.zoom));
            this.render();
        });
        canvas.addEventListener('click', e=>{
            const rect = canvas.getBoundingClientRect();
            const [col,row]=this.screenToCell(e.clientX-rect.left,e.clientY-rect.top);
            this.setCellColor(col,row,this.currentColor);
        });
    }
}

// Initialize the grid
const canvas = document.getElementById('glCanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const grid = new WebGLTriangleGrid(canvas);

// Set up controls
document.getElementById('colorPicker').addEventListener('input', e => {
    const c = e.target.value;
    const r = parseInt(c.substr(1,2),16)/255;
    const g = parseInt(c.substr(3,2),16)/255;
    const b = parseInt(c.substr(5,2),16)/255;
    grid.currentColor = [r,g,b,1];
});

document.getElementById('fillAll').addEventListener('click', () => {
    for(let r = 0; r < grid.gridRows; r++) {
        for(let c = 0; c < grid.gridCols; c++) {
            grid.setCellColor(c, r, grid.currentColor);
        }
    }
});

document.getElementById('clear').addEventListener('click', () => {
    grid.coloredTriangles = {};
    grid.render();
});

// Handle window resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    grid.render();
});
</script>
</body>
</html>
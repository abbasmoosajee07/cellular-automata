<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Cellular Automata</title>

    <!-- SEO -->
    <meta name="description" content="Interactive cellular automata simulator — Chaos disguised as order.">
    <meta name="keywords" content="cellular automata, game of life, conway, life">
    <meta name="robots" content="index, follow">

    <!-- Icons -->
    <link rel="icon" href="./assets/LOGO.png" type="image/x-icon">
    <link rel="shortcut icon" href="./assets/LOGO.png">
    <link rel="apple-touch-icon" href="./assets/LOGO.png">

    <!-- Styles & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="./styles.css">

</head>

<body>
    <!-- Toggle Button -->
    <button id="menuToggle" class="toggle-panel-btn">
        <i class="bi bi-three-dots-vertical"></i>
    </button>

    <!-- Collapsible Side Panel -->
    <div class="sidenav" id="menuPanel">
        <!-- Vertical Tabs on the left -->
        <div class="sidenav-tabs">
            <button class="tab-btn active" data-panel="aboutPanel">
                <i class="bi bi-info-circle-fill"></i>
            </button>
            <button class="tab-btn" data-panel="gridPanel" title="Grid Controls">
                <i class="bi bi-grid-3x3-gap-fill"></i>
            </button>
            <button class="tab-btn" data-panel="drawPanel">
                <i class="bi bi-pencil-fill"></i>
            </button>
            <button class="tab-btn" data-panel="logicPanel" title="Automata Logic">
                <i class="bi bi-cpu-fill"></i>
            </button>
            <button class="tab-btn" data-panel="statsPanel" title="Statistics">
                <i class="bi bi-graph-up"></i>
            </button>
        </div>

        <!-- Panel Content -->
        <div class="sidenav-panels">
            <!-- About Panel -->
            <div class="panel active" id="aboutPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-info-circle-fill me-2"></i> Cellular Automaton</h3>
                </div>
                <div class="container">
                    <!-- Your main panel content here -->

                    <!-- Footer section at bottom of panel -->
                    <div class="mt-auto pt-3 border-top">
                        <div class="mb-2">
                            &copy; <span id="year"></span> Abbas Moosajee &nbsp;|&nbsp;
                            <a href="https://github.com/abbasmoosajee07/cellular-automata" target="_blank" title="View Source Code" class="text-dark text-decoration-none">
                                <i class="bi bi-github align-middle"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Grid Panel -->
            <div class="panel" id="gridPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-grid-3x3-gap-fill me-2"></i> Grid Controls</h3>
                </div>
                <button class="action-btn" id="themeToggle" aria-label="Toggle theme">
                    <span id="themeText" class="ms-2"></span>
                    <i id="themeIcon" class="bi"></i>
                </button>

                <div class="config-group">
                    <h3>Cell Shapes:</h3>
                    <div class="config-row">
                        <div class="config-option">
                            <input type="radio" id="shape-hex" name="shape" value="hex">
                            <label for="shape-hex">Hexagons</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="shape-triangle" name="shape" value="triangle">
                            <label for="shape-triangle">Triangle</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="shape-square" name="shape" value="square" checked>
                            <label for="shape-square">Square</label>
                        </div>
                    </div>
                </div>

                <div class="config-group">
                    <h3>Neighbor Rules</h3>
                    <div class="config-row">
                        <div class="config-option">
                            <input type="radio" id="neighbors-adjacent" name="neighbors" value="adjacent" checked>
                            <label for="neighbors-adjacent">Adjacent Only</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="neighbors-touching" name="neighbors" value="touching">
                            <label for="neighbors-touching">All Touching</label>
                        </div>
                    </div>
                </div>

                <div class="config-group">
                    <h3>Boundary Behavior</h3>
                    <div class="config-row">
                        <div class="config-option">
                            <input type="radio" id="bounds-infinite" name="bounds" value="infinite">
                            <label for="bounds-infinite">Infinite</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="bounds-wrap" name="bounds" value="wrap-around" checked>
                            <label for="bounds-wrap">Wrap-around</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="bounds-bounded" name="bounds" value="bounded">
                            <label for="bounds-bounded">Bounded</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="bounds-cliff" name="bounds" value="cliff">
                            <label for="bounds-cliff">Fall off</label>
                        </div>
                    </div>
                </div>

                <div class="form-row">
                    <label for="colInput">Cols:</label>
                    <input type="number" class="grid-size-in" id="colInput" min="1" value="20" step="1">
                </div>

                <div class="form-row">
                    <label for="rowInput">Rows:</label>
                    <input type="number" class="grid-size-in" id="rowInput" min="1" value="20" step="1">
                </div>
            </div>

            <!-- Draw Panel -->
            <div class="panel" id="drawPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-pencil-fill me-2"></i> Drawing Tools</h3>
                </div>

                <div class="form-row">
                    <label for="drawTiles">Draw Tiles</label>
                    <input type="checkbox" id="drawTiles">
                </div>

                <div class="form-row">
                    <label for="eraseTiles">Erase Tiles</label>
                    <input type="checkbox" id="eraseTiles">
                </div>

                <button id="clearGrid" class="action-btn" title="Clear">
                    <i class="bi bi-trash-fill"></i> Clear
                </button>

                <button id="randomFill" class="action-btn" title="Random">
                    <i class="bi bi-shuffle"></i> Random
                </button>
                <button id="neighborTiles" class="action-btn" title="Add Neighbors">
                    <i class="bi bi-bounding-box"></i> Neighbor Tiles
                </button>
            </div>

            <!-- Logic Panel -->
            <div class="panel" id="logicPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-cpu-fill me-2"></i> Automata Logic</h3>
                </div>
                <!-- Add your logic panel content here -->
            </div>

            <!-- Stats Panel -->
            <div class="panel" id="statsPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-graph-up me-2"></i> Statistics</h3>
                </div>
                <!-- Add your stats panel content here -->
            </div>
        </div>
    </div>

    <!-- Main Canvas -->
    <canvas id="gridCanvas"></canvas>

    <div class="control-panel">
        <button id="resetView" class="control-btn" title="Reset View">
            <i class="bi bi-camera-video-fill"></i>
        </button>

        <button id="pinLoc" class="control-btn" title="Pin Location">
            <i class="bi bi-pin-map-fill"></i>
        </button>

        <button id="simCtrl" class="control-btn" title="Pin Location">
            <i class="bi bi-play-fill"></i>
        </button>
    </div>

    <script src="./scripts/utils.js"></script>
    <script>

        class SquareGrid {
            constructor(colorSchema, detailed, simple) {
                this.colorSchema = colorSchema;
                this.DETAILED_GRID_SIZE = detailed;
                this.SIMPLIFIED_GRID_SIZE = simple;
                this.radius = 30;
                this.zoom = 1;
                this.baseCellSize = 60; // 30 radius * 2
                
                // Texture properties
                this.gridTexture = null;
                this.textureData = null;
                this.gridSize = 50; // Default grid size

                // Shape-specific properties
                this.shape = "square";
            }

            // Shape-specific WebGL shader source
            getVertexShaderSource() {
                return `
                    attribute vec2 aPosition;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        gl_Position = vec4(aPosition, 0.0, 1.0);
                        vTexCoord = aPosition * 0.5 + 0.5;
                    }
                `;
            }

            getFragmentShaderSource() {
                return `
                    precision mediump float;
                    uniform vec2 uResolution;
                    uniform vec2 uOffset;
                    uniform float uScale;
                    uniform float uGridSize;
                    uniform float uBaseCellSize;
                    uniform vec4 uDrawColor;
                    uniform vec4 uBgColor;
                    uniform sampler2D uGridTexture;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        // Convert to world coordinates (centered at 0,0)
                        vec2 worldPos = (vTexCoord * uResolution - uResolution * 0.5 - uOffset) / uScale;
                        
                        // Calculate grid coordinates using base cell size
                        // Grid is centered at (0,0) in world space
                        float halfGridWorld = uGridSize * uBaseCellSize * 0.5;
                        vec2 gridPos = floor((worldPos + halfGridWorld) / uBaseCellSize);
                        
                        // Check if within grid bounds
                        if (gridPos.x >= 0.0 && gridPos.x < uGridSize && gridPos.y >= 0.0 && gridPos.y < uGridSize) {
                            // Sample from grid texture
                            vec2 texCoord = gridPos / uGridSize;
                            vec4 cellValue = texture2D(uGridTexture, texCoord);
                            
                            if (cellValue.a > 0.5) {
                                gl_FragColor = uDrawColor;
                            } else {
                                gl_FragColor = uBgColor;
                            }
                        } else {
                            // Outside grid bounds
                            gl_FragColor = uBgColor;
                        }
                    }
                `;
            }
            screenToWorld(px, py, width, height, cameraView) {
                // Convert screen coordinates to world coordinates
                // Screen: (0,0) at top-left, (width,height) at bottom-right
                // World: (0,0) at center, positive Y up
                const worldX = (px - width / 2 - cameraView.camX) / cameraView.zoom;
                const worldY = (height / 2 - py - cameraView.camY) / cameraView.zoom; // Flip Y axis
                return { x: worldX, y: worldY };
            }
            // Shape-specific coordinate conversion
            worldToCell(world) {
                const size = this.baseCellSize;
                // Convert from world coordinates to grid coordinates
                // World coordinates are centered at (0,0), grid coordinates start at (0,0) in top-left
                const halfGridSize = (this.gridSize * size) / 2;
                const cellX = Math.floor((world.x + halfGridSize) / size);
                const cellY = Math.floor((world.y + halfGridSize) / size);
                return [cellX, cellY];
            }

            // Shape-specific bounds calculation
            calculateBounds(bounds) {
                const [minX, maxX, minY, maxY] = bounds;
                const size = this.baseCellSize;

                const minCol = Math.floor(minX / size) - 1;
                const maxCol = Math.ceil(maxX / size) + 1;
                const minRow = Math.floor(minY / size) - 1;
                const maxRow = Math.ceil(maxY / size) + 1;

                return [minCol, maxCol, minRow, maxRow];
            }

            // Shape-specific geometry setup
            setupGeometryBuffers(gl) {
                // Create vertex buffer for full-screen quad
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                
                const vertices = new Float32Array([
                    -1.0, -1.0,  // bottom left
                    1.0, -1.0,   // bottom right
                    1.0, 1.0,    // top right
                    -1.0, 1.0    // top left
                ]);
                
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                // Create index buffer
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                
                return {
                    vertexBuffer: this.vertexBuffer,
                    indexBuffer: this.indexBuffer,
                    vertexCount: 4,
                    indexCount: 6
                };
            }

            // Shape-specific uniform setup
            setupUniforms(gl, program, cameraView, geometry, drawColor, bgColor, width, height) {
                const uniformLocations = {
                    resolution: gl.getUniformLocation(program, 'uResolution'),
                    offset: gl.getUniformLocation(program, 'uOffset'),
                    scale: gl.getUniformLocation(program, 'uScale'),
                    gridSize: gl.getUniformLocation(program, 'uGridSize'),
                    baseCellSize: gl.getUniformLocation(program, 'uBaseCellSize'),
                    drawColor: gl.getUniformLocation(program, 'uDrawColor'),
                    bgColor: gl.getUniformLocation(program, 'uBgColor'),
                    gridTexture: gl.getUniformLocation(program, 'uGridTexture')
                };

                gl.uniform2f(uniformLocations.resolution, width, height);
                gl.uniform2f(uniformLocations.offset, cameraView.camX, cameraView.camY);
                gl.uniform1f(uniformLocations.scale, cameraView.zoom);
                gl.uniform1f(uniformLocations.gridSize, geometry.gridSize);
                gl.uniform1f(uniformLocations.baseCellSize, geometry.baseCellSize);
                gl.uniform4fv(uniformLocations.drawColor, drawColor);
                gl.uniform4fv(uniformLocations.bgColor, bgColor);
                
                return uniformLocations;
            }

            initGridTexture(gl, gridSize) {
                this.gridSize = gridSize;
                this.textureData = new Uint8Array(gridSize * gridSize * 4);
                
                // Initialize texture data to empty
                for (let i = 0; i < gridSize * gridSize * 4; i += 4) {
                    this.textureData[i] = 0;     // R
                    this.textureData[i + 1] = 0; // G
                    this.textureData[i + 2] = 0; // B
                    this.textureData[i + 3] = 0; // A (0 = transparent)
                }
                
                // Create WebGL texture
                this.gridTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridSize, gridSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            resizeGridTexture(gl, newGridSize, oldCells) {
                // Save current texture data
                const oldData = this.textureData;
                const oldSize = this.gridSize;
                
                // Create new texture with new size
                this.initGridTexture(gl, newGridSize);
                
                // Copy old cell data to new texture
                if (oldCells && oldData) {
                    for (let y = 0; y < Math.min(oldSize, newGridSize); y++) {
                        for (let x = 0; x < Math.min(oldSize, newGridSize); x++) {
                            const oldIndex = (y * oldSize + x) * 4;
                            const newIndex = (y * newGridSize + x) * 4;
                            
                            // Check if cell was alive in old data
                            if (oldData[oldIndex + 3] > 0) {
                                this.setCellState(gl, x, y, true);
                            }
                        }
                    }
                }
            }

            updateGridTexture(gl) {
                if (!this.gridTexture) return;
                
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.gridSize, this.gridSize, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            setCellState(gl, x, y, state) {
                if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                    const index = (y * this.gridSize + x) * 4;
                    
                    if (state) {
                        // Filled cell - use the color from schema
                        const color = this.colorSchema[1] || [1, 1, 1, 1];
                        this.textureData[index] = color[0] * 255;     // R
                        this.textureData[index + 1] = color[1] * 255; // G
                        this.textureData[index + 2] = color[2] * 255; // B
                        this.textureData[index + 3] = 255;            // A
                    } else {
                        // Empty cell - transparent
                        this.textureData[index] = 0;
                        this.textureData[index + 1] = 0;
                        this.textureData[index + 2] = 0;
                        this.textureData[index + 3] = 0;
                    }
                    
                    // Update single pixel in texture
                    gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                    const pixelData = new Uint8Array([
                        this.textureData[index],
                        this.textureData[index + 1],
                        this.textureData[index + 2],
                        this.textureData[index + 3]
                    ]);
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
                    
                    return true;
                }
                return false;
            }

            fillGrid(gl) {
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        this.setCellState(gl, x, y, true);
                    }
                }
            }

            clearGrid(gl) {
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        this.setCellState(gl, x, y, false);
                    }
                }
            }

            getGridGeometry(bounds, cells, maxCols, maxRows, infinite, gl) {
                // For texture-based approach, we don't need geometry
                // The entire grid is rendered with a full-screen quad
                return {
                    texture: this.gridTexture,
                    gridSize: this.gridSize,
                    baseCellSize: this.baseCellSize,
                    vertexCount: 4, // Full-screen quad
                    indexCount: 6   // Two triangles
                };
            }
        }

        class TriangleGrid {
            constructor(colorSchema, detailed, simple) {
                this.colorSchema = colorSchema;
                this.DETAILED_GRID_SIZE = detailed;
                this.SIMPLIFIED_GRID_SIZE = simple;

                this.sideLength = 60;
                this.height = this.sideLength * Math.sqrt(3) / 2; // Equilateral triangle height
                this.zoom = 1;
                this.gridSize = 50;

                this.gridTexture = null;
                this.textureData = null;
                this.shape = "triangle";

                this.bindMethods();
            }

            bindMethods() {
                const methods = [
                    'getVertexShaderSource', 'getFragmentShaderSource', 'setupGeometryBuffers',
                    'setupUniforms', 'initGridTexture', 'updateGridTexture', 'setCellState',
                    'screenToWorld', 'worldToCell', 'getGridGeometry'
                ];

                methods.forEach(method => {
                    if (this[method]) this[method] = this[method].bind(this);
                });
            }

            getVertexShaderSource() {
                return `
                    attribute vec2 aPosition;
                    varying vec2 vTexCoord;
                    void main() {
                        gl_Position = vec4(aPosition, 0.0, 1.0);
                        vTexCoord = aPosition * 0.5 + 0.5;
                    }
                `;
            }

            getFragmentShaderSource() {
                return `
                    precision mediump float;

                    uniform vec2 uResolution;
                    uniform vec2 uOffset;
                    uniform float uScale;
                    uniform float uGridSize;
                    uniform float uSideLength;
                    uniform float uHeight;
                    uniform vec4 uDrawColor;
                    uniform vec4 uBgColor;
                    uniform sampler2D uGridTexture;

                    varying vec2 vTexCoord;

                    void main() {
                        vec2 worldPos = (vTexCoord * uResolution - uResolution * 0.5 - uOffset) / uScale;
                        float s = uSideLength;
                        float h = uHeight;

                        // Compute row and column
                        float row = floor(worldPos.y / h);
                        float col = floor((worldPos.x - mod(row,2.0) * 0.5 * s) / s);

                        // Out-of-bounds check
                        if (row < 0.0 || row >= uGridSize * 2.0 || col < 0.0 || col >= uGridSize) {
                            gl_FragColor = uBgColor;
                            return;
                        }

                        // Local coordinates in triangle bounding box
                        float localX = worldPos.x - (col * s + mod(row,2.0) * 0.5 * s);
                        float localY = worldPos.y - row * h;

                        bool isUp = mod(row,2.0) < 0.5;
                        float slope = h / (s * 0.5);
                        bool inTriangle;

                        if (isUp) {
                            // Upward triangle (apex at top)
                            inTriangle = localY >= 0.0 && localY <= h - slope * abs(localX - s * 0.5);
                        } else {
                            // Downward triangle (apex at bottom)
                            inTriangle = localY <= h && localY >= slope * abs(localX - s * 0.5);
                        }

                        if (!inTriangle) {
                            gl_FragColor = uBgColor;
                            return;
                        }

                        // Sample cell from texture
                        vec2 texCoord = vec2(col + 0.5, row + 0.5) / vec2(uGridSize, uGridSize * 2.0);
                        vec4 cellValue = texture2D(uGridTexture, texCoord);

                        gl_FragColor = (cellValue.a > 0.1) ? uDrawColor : uBgColor;
                    }
                `;
            }

            setupGeometryBuffers(gl) {
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                const vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                return {
                    vertexBuffer: this.vertexBuffer,
                    indexBuffer: this.indexBuffer,
                    vertexCount: 4,
                    indexCount: 6
                };
            }

            setupUniforms(gl, program, cameraView, geometry, drawColor, bgColor, width, height) {
                const uniformLocations = {
                    resolution: gl.getUniformLocation(program, 'uResolution'),
                    offset: gl.getUniformLocation(program, 'uOffset'),
                    scale: gl.getUniformLocation(program, 'uScale'),
                    gridSize: gl.getUniformLocation(program, 'uGridSize'),
                    sideLength: gl.getUniformLocation(program, 'uSideLength'),
                    height: gl.getUniformLocation(program, 'uHeight'),
                    drawColor: gl.getUniformLocation(program, 'uDrawColor'),
                    bgColor: gl.getUniformLocation(program, 'uBgColor'),
                    gridTexture: gl.getUniformLocation(program, 'uGridTexture')
                };

                gl.uniform2f(uniformLocations.resolution, width, height);
                gl.uniform2f(uniformLocations.offset, cameraView.camX, cameraView.camY);
                gl.uniform1f(uniformLocations.scale, cameraView.zoom);
                gl.uniform1f(uniformLocations.gridSize, this.gridSize);
                gl.uniform1f(uniformLocations.sideLength, this.sideLength);
                gl.uniform1f(uniformLocations.height, this.height);
                gl.uniform4fv(uniformLocations.drawColor, drawColor);
                gl.uniform4fv(uniformLocations.bgColor, bgColor);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.uniform1i(uniformLocations.gridTexture, 0);

                return uniformLocations;
            }

            initGridTexture(gl, gridSize) {
                this.gridSize = gridSize;
                this.textureWidth = gridSize;
                this.textureHeight = gridSize * 2;

                this.textureData = new Uint8Array(this.textureWidth * this.textureHeight * 4);
                for (let i = 0; i < this.textureData.length; i += 4) {
                    this.textureData[i] = 255;
                    this.textureData[i + 1] = 255;
                    this.textureData[i + 2] = 255;
                    this.textureData[i + 3] = 255;
                }

                this.gridTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureWidth, this.textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            updateGridTexture(gl) {
                if (!this.gridTexture) return;
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.textureWidth, this.textureHeight, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            setCellState(gl, x, y, state) {
                if (x >= 0 && x < this.textureWidth && y >= 0 && y < this.textureHeight) {
                    const idx = (y * this.textureWidth + x) * 4;
                    if (state) {
                        const color = this.colorSchema[1] || [1, 1, 1, 1];
                        this.textureData[idx] = color[0] * 255;
                        this.textureData[idx + 1] = color[1] * 255;
                        this.textureData[idx + 2] = color[2] * 255;
                        this.textureData[idx + 3] = 255;
                    } else {
                        this.textureData[idx] = 0;
                        this.textureData[idx + 1] = 0;
                        this.textureData[idx + 2] = 0;
                        this.textureData[idx + 3] = 0;
                    }
                    this.updateGridTexture(gl);
                    return true;
                }
                return false;
            }

            screenToWorld(px, py, width, height, cameraView) {
                const worldX = (px - width / 2 - cameraView.camX) / cameraView.zoom;
                const worldY = (height / 2 - py - cameraView.camY) / cameraView.zoom;
                return { x: worldX, y: worldY };
            }

            worldToCell(world) {
                const s = this.sideLength;
                const h = this.height;

                const row = Math.floor(world.y / h);
                const col = Math.floor((world.x - (row % 2) * 0.5 * s) / s);

                if (row < 0 || row >= this.gridSize * 2 || col < 0 || col >= this.gridSize) return [-1, -1];

                const localX = world.x - (col * s + (row % 2) * 0.5 * s);
                const localY = world.y - row * h;

                const isUp = row % 2 === 0;
                const slope = h / (s * 0.5);
                const inTriangle = isUp
                    ? localY >= 0 && localY <= h - slope * Math.abs(localX - s / 2)
                    : localY <= h && localY >= slope * Math.abs(localX - s / 2);

                if (!inTriangle) return [-1, -1];
                return [col, row];
            }

            getGridGeometry(bounds, cells, maxCols, maxRows, infinite, gl) {
                return {
                    texture: this.gridTexture,
                    gridSize: this.gridSize,
                    baseCellSize: this.sideLength,
                    vertexCount: 4,
                    indexCount: 6
                };
            }

            fillGrid(gl) {
                for (let y = 0; y < this.textureHeight; y++) {
                    for (let x = 0; x < this.textureWidth; x++) {
                        this.setCellState(gl, x, y, true);
                    }
                }
            }

            clearGrid(gl) {
                for (let y = 0; y < this.textureHeight; y++) {
                    for (let x = 0; x < this.textureWidth; x++) {
                        this.setCellState(gl, x, y, false);
                    }
                }
            }
        }

        class HexagonGrid {
            constructor(colorSchema, detailed, simple) {
                this.colorSchema = colorSchema;
                this.DETAILED_GRID_SIZE = detailed;
                this.SIMPLIFIED_GRID_SIZE = simple;
                this.radius = 30;
                this.zoom = 1;
                this.gridSize = 50;
                this.gridTexture = null;
                this.textureData = null;
                this.shape = "hexagon";
            }

            resizeGridTexture(gl, newSize) {
                this.gridSize = newSize;
                this.textureData = new Uint8Array(newSize * newSize * 4);
                this.textureData.fill(0);
                if (!this.gridTexture) this.gridTexture = gl.createTexture();

                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, newSize, newSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            getVertexShaderSource() {
                return `
                    attribute vec2 aPosition;
                    varying vec2 vTexCoord;
                    void main() {
                        gl_Position = vec4(aPosition, 0.0, 1.0);
                        vTexCoord = aPosition * 0.5 + 0.5;
                    }
                `;
            }

            // ⬇️ Fixed flat-topped hex layout
            getFragmentShaderSource() {
                return `
                    precision mediump float;
                    uniform vec2 uResolution;
                    uniform vec2 uOffset;
                    uniform float uScale;
                    uniform float uGridSize;
                    uniform float uRadius;
                    uniform vec4 uDrawColor;
                    uniform vec4 uBgColor;
                    uniform sampler2D uGridTexture;
                    varying vec2 vTexCoord;

                    // flat-topped axial conversion
                    vec2 worldToHex(vec2 pos, float r) {
                        float q = (sqrt(3.0)/3.0 * pos.x - 1.0/3.0 * pos.y) / r;
                        float s = (2.0/3.0 * pos.y) / r;
                        return vec2(q, s);
                    }

                    ivec2 hexRound(vec2 h) {
                        float x = h.x;
                        float z = h.y;
                        float y = -x - z;
                        float rx = floor(x + 0.5);
                        float ry = floor(y + 0.5);
                        float rz = floor(z + 0.5);
                        float dx = abs(rx - x);
                        float dy = abs(ry - y);
                        float dz = abs(rz - z);
                        if (dx > dy && dx > dz) rx = -ry - rz;
                        else if (dy > dz) ry = -rx - rz;
                        else rz = -rx - ry;
                        return ivec2(int(rx), int(rz));
                    }

                    void main() {
                        vec2 worldPos = (vTexCoord * uResolution - uResolution*0.5 - uOffset) / uScale;
                        vec2 axial = worldToHex(worldPos, uRadius);
                        ivec2 cell = hexRound(axial);

                        // map to texture coords
                        vec2 texCoord = (vec2(float(cell.x) + uGridSize*0.5, float(cell.y) + uGridSize*0.5)) / uGridSize;

                        if (texCoord.x < 0.0 || texCoord.x > 1.0 || texCoord.y < 0.0 || texCoord.y > 1.0) {
                            gl_FragColor = uBgColor;
                            return;
                        }

                        vec4 cellValue = texture2D(uGridTexture, texCoord);
                        if (cellValue.a > 0.5)
                            gl_FragColor = uDrawColor;
                        else
                            gl_FragColor = uBgColor;
                    }
                `;
            }

            setupGeometryBuffers(gl) {
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                const vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                return { vertexBuffer, indexBuffer, vertexCount: 4, indexCount: 6 };
            }

            setupUniforms(gl, program, cameraView, geometry, drawColor, bgColor, width, height) {
                const u = {
                    resolution: gl.getUniformLocation(program, "uResolution"),
                    offset: gl.getUniformLocation(program, "uOffset"),
                    scale: gl.getUniformLocation(program, "uScale"),
                    gridSize: gl.getUniformLocation(program, "uGridSize"),
                    radius: gl.getUniformLocation(program, "uRadius"),
                    drawColor: gl.getUniformLocation(program, "uDrawColor"),
                    bgColor: gl.getUniformLocation(program, "uBgColor"),
                    gridTexture: gl.getUniformLocation(program, "uGridTexture")
                };
                gl.uniform2f(u.resolution, width, height);
                gl.uniform2f(u.offset, cameraView.camX, cameraView.camY);
                gl.uniform1f(u.scale, cameraView.zoom);
                gl.uniform1f(u.gridSize, geometry.gridSize);
                gl.uniform1f(u.radius, this.radius);
                gl.uniform4fv(u.drawColor, drawColor);
                gl.uniform4fv(u.bgColor, bgColor);
                return u;
            }

            initGridTexture(gl, gridSize) {
                this.gridSize = gridSize;
                this.textureData = new Uint8Array(gridSize * gridSize * 4);
                this.textureData.fill(0);
                this.gridTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridSize, gridSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            updateGridTexture(gl) {
                if (!this.gridTexture) return;
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.gridSize, this.gridSize, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            setCellState(gl, x, y, state) {
                if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                    const idx = (y * this.gridSize + x) * 4;
                    if (state) {
                        const color = this.colorSchema[1] || [1, 1, 1, 1];
                        this.textureData[idx]   = color[0] * 255;
                        this.textureData[idx+1] = color[1] * 255;
                        this.textureData[idx+2] = color[2] * 255;
                        this.textureData[idx+3] = 255;
                    } else {
                        this.textureData[idx] = this.textureData[idx+1] = this.textureData[idx+2] = this.textureData[idx+3] = 0;
                    }
                    const pixelData = this.textureData.slice(idx, idx + 4);
                    gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
                    return true;
                }
                return false;
            }

            screenToWorld(px, py, width, height, cameraView) {
                const texX = px / width;
                const texY = 1 - (py / height);
                const pixelX = texX * width;
                const pixelY = texY * height;
                const worldX = (pixelX - width * 0.5 - cameraView.camX) / cameraView.zoom;
                const worldY = (pixelY - height * 0.5 - cameraView.camY) / cameraView.zoom;
                return { x: worldX, y: worldY };
            }

            // match shader’s flat-topped version
            worldToCell(worldPos) {
                const q = ((Math.sqrt(3) / 3) * worldPos.x - (1 / 3) * worldPos.y) / this.radius;
                const s = ((2.0 / 3.0) * worldPos.y) / this.radius;
                let x = q, z = s;
                let y = -x - z;
                let rx = Math.round(x);
                let ry = Math.round(y);
                let rz = Math.round(z);
                const dx = Math.abs(rx - x);
                const dy = Math.abs(ry - y);
                const dz = Math.abs(rz - z);
                if (dx > dy && dx > dz) rx = -ry - rz;
                else if (dy > dz) ry = -rx - rz;
                else rz = -rx - ry;
                return [rx, rz];
            }

            getGridGeometry(bounds, cells, maxCols, maxRows, infinite, gl) {
                return { texture: this.gridTexture, gridSize: this.gridSize, baseCellSize: this.radius, vertexCount: 4, indexCount: 6 };
            }

        }

        class Canvas2DRenderer {
            constructor(canvas, shapeGrid) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.shapeGrid = shapeGrid;
                this.updateCanvasSize();
            }

            updateCanvasSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.width = width;
                this.height = height;
            }

            drawExact(cameraView, geometry, drawColor, bgColor, cells) {
                const ctx = this.ctx;
                
                // Clear canvas with background color
                ctx.fillStyle = `rgba(${Math.round(bgColor[0] * 255)}, ${Math.round(bgColor[1] * 255)}, ${Math.round(bgColor[2] * 255)}, ${bgColor[3]})`;
                ctx.fillRect(0, 0, this.width, this.height);
                
                if (!cells || cells.size === 0) return;

                // Set up transformation for camera view - match WebGL coordinate system
                ctx.save();
                ctx.translate(this.width / 2, this.height / 2);
                ctx.scale(cameraView.zoom, cameraView.zoom);
                ctx.translate(cameraView.camX, cameraView.camY);

                // Draw grid cells using the shape-specific rendering
                this.drawCells(ctx, cells, drawColor);

                ctx.restore();
            }

            drawCells(ctx, cells, drawColor) {
                const shape = this.shapeGrid.shape;
                
                ctx.fillStyle = `rgba(${Math.round(drawColor[0] * 255)}, ${Math.round(drawColor[1] * 255)}, ${Math.round(drawColor[2] * 255)}, ${drawColor[3]})`;
                
                switch (shape) {
                    case "square":
                        this.drawSquareCells(ctx, cells);
                        break;
                    case "hexagon":
                        this.drawHexagonCells(ctx, cells);
                        break;
                    case "triangle":
                        this.drawTriangleCells(ctx, cells);
                        break;
                    default:
                        this.drawSquareCells(ctx, cells);
                }
            }

            drawSquareCells(ctx, cells) {
                const cellSize = this.shapeGrid.baseCellSize || 60;
                const halfGridSize = (this.shapeGrid.gridSize * cellSize) / 2;
                
                for (const [col, colMap] of cells) {
                    for (const [row, state] of colMap) {
                        if (state) {
                            const worldX = col * cellSize - halfGridSize;
                            const worldY = row * cellSize - halfGridSize;
                            ctx.fillRect(worldX, worldY, cellSize, cellSize);
                        }
                    }
                }
            }

            drawHexagonCells(ctx, cells) {
                const radius = this.shapeGrid.radius || 30;
                
                for (const [q, colMap] of cells) {
                    for (const [r, state] of colMap) {
                        if (state) {
                            // PROPER flat-topped hexagon grid coordinates
                            // This creates a perfect honeycomb structure
                            const x = radius * Math.sqrt(3) * (q + r * 0.5);
                            const y = radius * 1.5 * r;
                            
                            this.drawFlatTopHexagon(ctx, x, y, radius);
                        }
                    }
                }
            }

            drawFlatTopHexagon(ctx, centerX, centerY, radius) {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i - Math.PI / 6; // -30° offset for flat-topped
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
            }

            drawTriangleCells(ctx, cells) {
                const cellSize = this.shapeGrid.baseCellSize || 60;
                const height = cellSize * Math.sqrt(3) / 2;
                
                for (const [col, colMap] of cells) {
                    for (const [row, state] of colMap) {
                        if (state) {
                            // Proper triangle grid that forms equilateral triangles
                            const x = col * (cellSize / 2);
                            const y = row * height;
                            
                            // Determine triangle orientation
                            const orientation = (col + row) % 2;
                            this.drawEquilateralTriangle(ctx, x, y, cellSize, orientation);
                        }
                    }
                }
            }

            drawEquilateralTriangle(ctx, x, y, size, orientation) {
                const height = size * Math.sqrt(3) / 2;
                
                ctx.beginPath();
                if (orientation === 0) {
                    // Pointing up
                    ctx.moveTo(x, y + height);
                    ctx.lineTo(x + size / 2, y);
                    ctx.lineTo(x + size, y + height);
                } else {
                    // Pointing down
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y + height);
                    ctx.lineTo(x + size, y);
                }
                ctx.closePath();
                ctx.fill();
            }
        }

        class WebGLRenderer {
            constructor(canvas, shapeGrid) {
                this.canvas = canvas;
                this.shapeGrid = shapeGrid;
                this.gl = this.initWebGL();
                if (!this.gl) {
                    throw new Error("WebGL not supported");
                }

                this.initShaders();
                this.initBuffers();
                this.updateCanvasSize();
                
                this.cachedGeometry = null;
            }

            initWebGL() {
                const gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!gl) {
                    console.error('WebGL not supported');
                    return null;
                }
                
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0, 0, 0, 0);
                
                return gl;
            }

            initShaders() {
                const gl = this.gl;

                const vsSource = this.shapeGrid.getVertexShaderSource();
                const fsSource = this.shapeGrid.getFragmentShaderSource();

                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fsSource);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Shader program failed to link:', gl.getProgramInfoLog(this.program));
                }

                this.attribLocations = {
                    position: gl.getAttribLocation(this.program, 'aPosition')
                };
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            initBuffers() {
                const buffers = this.shapeGrid.setupGeometryBuffers(this.gl);
                this.vertexBuffer = buffers.vertexBuffer;
                this.indexBuffer = buffers.indexBuffer;
                this.vertexCount = buffers.vertexCount;
                this.indexCount = buffers.indexCount;
            }

            updateCanvasSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.width = width;
                this.height = height;
                
                const gl = this.gl;
                gl.viewport(0, 0, width, height);
            }

            uploadGeometry(geometry) {
                this.cachedGeometry = geometry;
            }

            draw(cameraView, gridGeometry, drawColor, bgColor) {
                const gl = this.gl;
                
                if (!gridGeometry || !gridGeometry.texture) {
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    return;
                }

                gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.useProgram(this.program);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.enableVertexAttribArray(this.attribLocations.position);
                gl.vertexAttribPointer(this.attribLocations.position, 2, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                const uniformLocations = this.shapeGrid.setupUniforms(
                    gl, this.program, cameraView, gridGeometry, drawColor, bgColor, this.width, this.height
                );
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, gridGeometry.texture);
                gl.uniform1i(uniformLocations.gridTexture, 0);
                
                gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
            }
        }

        class GridManager {
            adj_neighbors = [[0, -1], [0, 1], [1, 0], [-1, 0]];

            constructor(shape, canvas, init_cells = new Map(), useWebGL = false) {
                this.shape = shape.value || shape;
                this.canvas = canvas;
                this.useWebGL = useWebGL;
                this.cells = init_cells;
                this.neighborsMap = new Map();

                // Grid defaults
                this.gridRows = 20;
                this.gridCols = 20;
                this.infiniteGrid = false;
                this.boundaryType = "wrap";
                this.neighborType = "adjacent";

                // Performance settings
                this.detail = 1;
                this.simple = 2;

                // Camera & colors
                this.cameraView = { camX: 0, camY: 0, zoom: 1 };
                this.colorSchema = {
                    line: this.hexToRgb("#555555"),
                    1: this.hexToRgb("#32cd32"),
                };
                this.drawColor = this.colorSchema[1];
                this.bgColor = this.hexToRgb("#0a0a1a");

                // Initialize shape-specific grid
                this.shapeGrid = this.createShapeGrid(this.shape);
                
                // Initialize renderer (WebGL or Canvas2D)
                this.initializeRenderer(this.useWebGL);
                
                // Initialize grid - only call initGridTexture if we have a valid WebGL context
                if (this.useWebGL && this.renderer.gl) {
                    this.shapeGrid.initGridTexture(this.renderer.gl, this.gridCols);
                } else {
                    // For Canvas2D, manually set the grid size without calling initGridTexture
                    this.shapeGrid.gridSize = this.gridCols;
                    this.shapeGrid.useWebGL = false;
                }
                
                // Sync existing cells
                this.syncCellsToTexture();
                
                this.updateCanvasSize();
                
                // Start continuous rendering
                this.startRendering();
            }

            getVisibleBounds() {
                const halfW = this.width / (2 * this.cameraView.zoom);
                const halfH = this.height / (2 * this.cameraView.zoom);

                const minWorldX = -this.cameraView.camX / this.cameraView.zoom - halfW;
                const maxWorldX = -this.cameraView.camX / this.cameraView.zoom + halfW;
                const minWorldY = -this.cameraView.camY / this.cameraView.zoom - halfH;
                const maxWorldY = -this.cameraView.camY / this.cameraView.zoom + halfH;

                return [minWorldX, maxWorldX, minWorldY, maxWorldY];
            }

            syncCellsToTexture() {
                // Sync existing cells data
                for (const [col, colMap] of this.cells) {
                    for (const [row, state] of colMap) {
                        if (state && col < this.gridCols && row < this.gridRows) {
                            // Only update texture if in WebGL mode
                            if (this.useWebGL && this.renderer.gl) {
                                this.shapeGrid.setCellState(this.renderer.gl, col, row, state);
                            }
                        }
                    }
                }
            }

            initializeRenderer(useWebGL) {
                try {
                    if (useWebGL) {
                        this.renderer = new WebGLRenderer(this.canvas, this.shapeGrid);
                        console.log("Using WebGL texture-based renderer");
                        this.useWebGL = true;
                    } else {
                        this.renderer = new Canvas2DRenderer(this.canvas, this.shapeGrid);
                        console.log("Using Canvas2D renderer");
                        this.useWebGL = false;
                    }
                } catch (error) {
                    console.warn("WebGL not supported, falling back to Canvas2D:", error);
                    this.renderer = new Canvas2DRenderer(this.canvas, this.shapeGrid);
                    this.useWebGL = false;
                }
            }

            startRendering() {
                const renderLoop = () => {
                    this.drawGrid();
                    requestAnimationFrame(renderLoop);
                };
                renderLoop();
            }

            // FIXED: Proper screen to world coordinate conversion
            screenToWorld(px, py) {
                return this.shapeGrid.screenToWorld(px, py, this.width, this.height, this.cameraView);
            }

            worldToCell(world) {
                return this.shapeGrid.worldToCell(world);
            }

            // FIXED: Direct screen to cell conversion for better accuracy
            screenToCell(px, py) {
                const world = this.screenToWorld(px, py);
                return this.worldToCell(world);
            }

            setBoundaryType(boundaryType) {
                this.boundaryType = boundaryType;
                this.infiniteGrid = (boundaryType === "infinite");
            }

            getNeighbors(x, y) {
                const neighbors = [];
                for (const [dx, dy] of this.adj_neighbors) {
                    const nx = dx + x;
                    const ny = dy + y;
                    neighbors.push([nx, ny]);
                }
                return neighbors;
            }

            buildNeighborsMap() {
                const neighborsMap = new Map();
                const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                for (let c = minCol; c <= maxCol; c++) {
                    for (let r = minRow; r <= maxRow; r++) {
                        const cellNeighbors = this.getNeighbors(c, r)
                        neighborsMap.set([c, r], cellNeighbors);
                    }
                }
                console.log("Neighbors dict", neighborsMap);
            }

            addNeighbors(x, y) {
                const valid_neighbors = this.getNeighbors(x, y);
                this.neighborsMap.set([x, y], valid_neighbors)
            }

            randomCells() {
                const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                console.log(minCol, maxCol, minRow, maxRow);
                for (let c = minCol; c <= maxCol; c++) {
                    for (let r = minRow; r <= maxRow; r++) {
                        const status = Math.random() < 0.5 ? 0 : 1;
                        this.changeCell(c, r, status);
                    }
                }
            }

            updateCanvasSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.canvas.width = width;
                this.canvas.height = height;
                this.width = width;
                this.height = height;

                if (this.renderer && this.renderer.updateCanvasSize) {
                    this.renderer.updateCanvasSize();
                }
            }

            getVisibleBounds() {
                const halfW = this.width / (2 * this.cameraView.zoom);
                const halfH = this.height / (2 * this.cameraView.zoom);

                const minWorldX = -this.cameraView.camX / this.cameraView.zoom - halfW;
                const maxWorldX = -this.cameraView.camX / this.cameraView.zoom + halfW;
                const minWorldY = -this.cameraView.camY / this.cameraView.zoom - halfH;
                const maxWorldY = -this.cameraView.camY / this.cameraView.zoom + halfH;

                return [minWorldX, maxWorldX, minWorldY, maxWorldY];
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255,
                    1.0
                ] : [0.5, 0.5, 0.5, 1.0];
            }

            changeCell(x, y, state) {
                if (!this.cells.has(x)) this.cells.set(x, new Map());
                this.cells.get(x).set(y, state);
                
                // Update texture only if in WebGL mode
                if (this.useWebGL && this.renderer.gl) {
                    this.shapeGrid.setCellState(this.renderer.gl, x, y, state);
                }
                
                this.addNeighbors(x, y);
            }

            getBounds() {
                const cols = Number(this.gridCols) || 0;
                const rows = Number(this.gridRows) || 0;

                const minCol = 0;
                const maxCol = cols - 1;
                const minRow = 0;
                const maxRow = rows - 1;

                return [minCol, maxCol, minRow, maxRow];
            }

            checkBounds(x, y) {
                if (!this.infiniteGrid) {
                    const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                    if (x < minCol || x > maxCol || y < minRow || y > maxRow) {
                        return false;
                    }
                }
                return true;
            }

            toggleAt(px, py, drawMode, eraseMode) {
                // Use direct screen to cell conversion for better accuracy
                const cell = this.screenToCell(px, py);
                if (!cell) return false;

                const [x, y] = cell;

                if (!this.checkBounds(x, y)) return false;

                let newState;
                if (drawMode) {
                    newState = 1;
                } else if (eraseMode) {
                    newState = 0;
                } else {
                    // safer check: ensure y exists in nested Map
                    const currentState = (this.cells.has(x) && this.cells.get(x).has(y)) ? this.cells.get(x).get(y) : 0;
                    newState = currentState ? 0 : 1;
                }

                this.changeCell(x, y, newState);
                return true;
            }

            fillAll() {
                // Update texture only if in WebGL mode
                if (this.useWebGL && this.renderer.gl) {
                    this.shapeGrid.fillGrid(this.renderer.gl);
                }
                
                // Also update the cells map
                const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                for (let c = minCol; c <= maxCol; c++) {
                    for (let r = minRow; r <= maxRow; r++) {
                        if (!this.cells.has(c)) this.cells.set(c, new Map());
                        this.cells.get(c).set(r, 1);
                    }
                }
            }

            clearAll() {
                // Update texture only if in WebGL mode
                if (this.useWebGL && this.renderer.gl) {
                    this.shapeGrid.clearGrid(this.renderer.gl);
                }
                this.cells.clear();
            }

            // Add method for continuous drawing
            drawLineBetweenPoints(startWorld, endWorld, mode) {
                const startCell = this.worldToCell(startWorld);
                const endCell = this.worldToCell(endWorld);
                
                if (!startCell || !endCell) return;

                const [x1, y1] = startCell;
                const [x2, y2] = endCell;

                // Simple line drawing algorithm
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;

                let x = x1;
                let y = y1;

                while (true) {
                    if (this.checkBounds(x, y)) {
                        const state = (mode === 'draw') ? 1 : 0;
                        this.changeCell(x, y, state);
                    }

                    if (x === x2 && y === y2) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
            }

            // NEW: Method to resize the grid
            resizeGrid(newCols, newRows) {
                const oldCols = this.gridCols;
                const oldRows = this.gridRows;
                
                this.gridCols = newCols;
                this.gridRows = newRows;
                
                // Save current cells data
                const oldCells = new Map();
                for (const [col, colMap] of this.cells) {
                    if (col < newCols) {
                        const newColMap = new Map();
                        for (const [row, state] of colMap) {
                            if (row < newRows && state) {
                                newColMap.set(row, state);
                            }
                        }
                        if (newColMap.size > 0) {
                            oldCells.set(col, newColMap);
                        }
                    }
                }
                
                // Resize the texture (only in WebGL mode)
                if (this.useWebGL && this.renderer.gl) {
                    this.shapeGrid.resizeGridTexture(this.renderer.gl, newCols, oldCells);
                } else {
                    // For Canvas2D, just update the grid size
                    this.shapeGrid.gridSize = newCols;
                }
                
                // Update cells with the resized data
                this.cells = oldCells;
                
                // Re-center the view
                this.centerView();
            }

            centerView() {
                // Center the view on the grid
                const gridWorldWidth = this.gridCols * this.shapeGrid.baseCellSize;
                const gridWorldHeight = this.gridRows * this.shapeGrid.baseCellSize;
                
                this.cameraView.camX = 0;
                this.cameraView.camY = 0;
                this.cameraView.zoom = 1;
            }

            // Update the drawGrid method to pass cells to Canvas2D renderer
            drawGrid() {
                const bounds = this.getVisibleBounds();
                
                const geometry = this.shapeGrid.getGridGeometry(
                    bounds, this.cells, this.gridCols, this.gridRows, this.infiniteGrid, null
                );

                if (this.useWebGL) {
                    // WebGL path
                    this.renderer.uploadGeometry(geometry);
                    this.renderer.draw(this.cameraView, geometry, this.drawColor, this.bgColor);
                } else {
                    // Canvas2D path - pass cells for rendering
                    this.renderer.drawExact(this.cameraView, geometry, this.drawColor, this.bgColor, this.cells);
                }
            }

            createShapeGrid(shape) {
                const { colorSchema, detail, simple } = this;
                switch (shape) {
                    case "square":   return new SquareGrid(colorSchema, detail, simple);
                    case "hex":  return new HexagonGrid(colorSchema, detail, simple);
                    case "triangle":  return new TriangleGrid(colorSchema, detail, simple);
                    default:
                        throw new Error(`Unknown grid shape: ${shape}`);
                }
            }

            // Update bounds checking for hexagon grid
            checkBounds(q, r) {
                if (!this.infiniteGrid) {
                    if (this.shapeGrid.shape === "hexagon") {
                        // For hexagon grid, check if within the hexagonal bounds
                        const center = this.gridCols / 2;
                        const radius = this.gridCols / 2;
                        return Math.abs(q) <= radius && Math.abs(r) <= radius && Math.abs(q + r) <= radius;
                    } else {
                        // Square grid bounds check
                        const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                        if (q < minCol || q > maxCol || r < minRow || r > maxRow) {
                            return false;
                        }
                    }
                }
                return true;
            }

            // Update getBounds for hexagon grid
            getBounds() {
                const cols = Number(this.gridCols) || 0;
                const rows = Number(this.gridRows) || 0;

                if (this.shapeGrid.shape === "hexagon") {
                    // Hexagon grid bounds (axial coordinates)
                    const radius = Math.floor(cols / 2);
                    return [-radius, radius, -radius, radius];
                } else {
                    // Square grid bounds
                    const minCol = 0;
                    const maxCol = cols - 1;
                    const minRow = 0;
                    const maxRow = rows - 1;
                    return [minCol, maxCol, minRow, maxRow];
                }
            }

            drawGrid() {
                const bounds = this.getVisibleBounds();
                
                const geometry = this.shapeGrid.getGridGeometry(
                    bounds, this.cells, this.gridCols, this.gridRows, this.infiniteGrid, null
                );

                if (this.useWebGL) {
                    // WebGL path
                    this.renderer.uploadGeometry(geometry);
                    this.renderer.draw(this.cameraView, geometry, this.drawColor, this.bgColor);
                } else {
                    // Canvas2D path - pass cells for rendering
                    this.renderer.drawExact(this.cameraView, geometry, this.drawColor, this.bgColor, this.cells);
                }
            }
        }

        class AutomataSimulator{
            docIDs = [
                "gridCanvas", "menuPanel", "menuToggle", "drawTiles", "eraseTiles",
                "rowInput", "colInput", "resetView", "pinLoc", "clearGrid", "randomFill",
                "neighborTiles",
            ]

            constructor(){
                this.initElements();
                this.initGrid();
                this.setupGridControls()
                this.setupEventListeners();
                this.setupCanvasControls();
                this.setupMenuControls();
                this.gridManager.drawGrid();
            }

            initElements() {
                for (const id of this.docIDs) {
                    this[id] = document.getElementById(id);
                }
            }

            delElements() {
                this.docIDs.forEach(id => {
                    const elem = document.getElementById(id);
                    if (elem) {
                        const newElem = elem.cloneNode(true);
                        elem.parentNode.replaceChild(newElem, elem);
                    }
                });
            }

            setupMenuControls() {
                const panel = this.menuPanel;

                this.menuToggle.addEventListener('click', () => {
                panel.classList.toggle('open');
                });
                document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // deactivate all
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.sidenav-panels .panel').forEach(p => p.classList.remove('active'));

                    // activate chosen
                    btn.classList.add('active');
                    document.getElementById(btn.dataset.panel).classList.add('active');
                });
                });
            }

            initGrid() {
                this.gridManager = new GridManager("square", this.gridCanvas);
                this.savedView = { ...this.gridManager.cameraView };
                this.gridManager.gridRows = parseInt(this.rowInput.value);
                this.gridManager.gridCols = parseInt(this.colInput.value);
            }

            setupGridControls() {
                // Store references to all shape radio buttons
                this.shapeRadios = document.querySelectorAll('input[name="shape"]');
                this.shapeRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                            const selectedShape = radio.value;
                            const old_grid = this.gridManager

                            this.gridManager = new GridManager(selectedShape, this.gridCanvas, old_grid.cells);
                            this.gridManager.cameraView = { ...old_grid.cameraView };
                            this.gridManager.gridRows = old_grid.gridRows;
                            this.gridManager.gridCols = old_grid.gridCols;
                            this.gridManager.infiniteGrid = old_grid.infiniteGrid;
                            this.gridManager.drawGrid();
                        }
                    });
                });

                this.rowInput.addEventListener('input', () => {
                    const newRows = parseInt(this.rowInput.value);
                    const newCols = parseInt(this.colInput.value);
                    this.gridManager.resizeGrid(newCols, newRows);
                    this.gridManager.drawGrid();
                });

                this.colInput.addEventListener('input', () => {
                    const newRows = parseInt(this.rowInput.value);
                    const newCols = parseInt(this.colInput.value);
                    this.gridManager.resizeGrid(newCols, newRows);
                    this.gridManager.drawGrid();
                });

                // Store references to all neighbors radio buttons
                this.neighborsRadio = document.querySelectorAll('input[name="neighbors"]');
                // Add event listener to each radio button
                this.neighborsRadio.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                        };
                    });
                });

                // Store references to all boundary radio buttons
                this.boundsRadio = document.querySelectorAll('input[name="bounds"]');
                this.boundsRadio.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                            this.gridManager.setBoundaryType(radio.value);
                            this.gridManager.drawGrid();
                        }
                    });
                });
            }

            setupEventListeners() {
                this.resetView.addEventListener('click', () => {
                    this.gridManager.cameraView = { ...this.savedView };
                    this.gridManager.drawGrid();
                });

                this.pinLoc.addEventListener('click', () => {
                    this.savedView = { ...this.gridManager.cameraView };
                });

                this.clearGrid.addEventListener('click', () => {
                    // use existing API so texture and internal state both cleared
                    this.gridManager.clearAll();
                    this.gridManager.drawGrid();
                });

                this.randomFill.addEventListener('click', () => this.gridManager.randomCells());

                window.addEventListener('resize', () => {
                    this.gridManager.updateCanvasSize();
                    this.gridManager.drawGrid();
                });

                this.neighborTiles.addEventListener('click', () => {
                    const availCells = this.gridManager.cells;
                    const neighborsToActivate = [];

                    // Collect neighbors of all active cells
                    for (const [col, colMap] of availCells) {
                        for (const [row, cellData] of colMap) {
                            if (cellData === 1) { // expand only from alive cells
                                const neighborCells = this.gridManager.getNeighbors(col, row);
                                neighborsToActivate.push(...neighborCells); // just dump them in
                            }
                        }
                    }

            // Apply neighbor activation
            for (const [nc, nr] of neighborsToActivate) {
                this.gridManager.changeCell(nc, nr, 1);
            }

            this.gridManager.drawGrid();
        });


            }

            setupCanvasControls() {
                let painting = false;
                let draggingCam = false;
                let lastX = 0, lastY = 0;
                let lastTouchDistance = null;
                const MIN_ZOOM = 10;
                const MAX_ZOOM = 0.001;

                const getPointer = (e) => {
                    if (e.touches && e.touches.length > 0) {
                        return { x: e.touches[0].clientX, y: e.touches[0].clientY, touches: e.touches.length };
                    }
                    return { x: e.clientX, y: e.clientY, touches: 1 };
                };

                const handleDown = (pointer) => {
                    if (pointer.touches === 1) {
                        if (this.drawTiles.checked || this.eraseTiles.checked) {
                            painting = true;
                            this.toggleAt(pointer.x, pointer.y);
                        } else {
                            draggingCam = true;
                        }
                        lastX = pointer.x;
                        lastY = pointer.y;
                    } else if (pointer.touches === 2) {
                        painting = false;
                        draggingCam = false;
                        lastTouchDistance = null;
                    }
                };

                const handleMove = (e) => {
                    if (e.touches && e.touches.length === 2) {
                        // Pinch zoom
                        const [t1, t2] = e.touches;
                        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                        if (lastTouchDistance) {
                            const zoomFactor = dist / lastTouchDistance;
                            const newZoom = this.gridManager.cameraView.zoom * zoomFactor;
                            this.gridManager.cameraView.zoom = Math.max(MAX_ZOOM, Math.min(MIN_ZOOM, newZoom));
                            this.gridManager.drawGrid();
                        }
                        lastTouchDistance = dist;
                        return;
                    }

                    const pointer = getPointer(e);
                    if (painting) {
                        this.toggleAt(pointer.x, pointer.y);
                    }
                    if (draggingCam) {
                        this.gridManager.cameraView.camX += pointer.x - lastX;
                        this.gridManager.cameraView.camY += pointer.y - lastY;
                        lastX = pointer.x;
                        lastY = pointer.y;
                        this.gridManager.drawGrid();
                    }
                };

                const handleUp = () => {
                    painting = false;
                    draggingCam = false;
                    lastTouchDistance = null;
                };

                // Mouse
                this.gridCanvas.addEventListener('mousedown', (e) => handleDown(getPointer(e)));
                this.gridCanvas.addEventListener('mousemove', handleMove);
                this.gridCanvas.addEventListener('mouseup', handleUp);
                this.gridCanvas.addEventListener('mouseleave', handleUp);

                // Touch
                this.gridCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleDown(getPointer(e)); });
                this.gridCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); });
                this.gridCanvas.addEventListener('touchend', handleUp);
                this.gridCanvas.addEventListener('touchcancel', handleUp);

                // Context menu disable
                this.gridCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Wheel zoom
                this.gridCanvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = this.gridManager.cameraView.zoom * zoomFactor;
                    this.gridManager.cameraView.zoom = Math.max(MAX_ZOOM, Math.min(MIN_ZOOM, newZoom));
                    this.gridManager.drawGrid();
                }, { passive: false });

                // Prevent elastic scrolling
                this.gridCanvas.style.touchAction = 'none';
            }

            toggleAt(px, py) {
                this.gridManager.toggleAt(
                    px, py,
                    this.drawTiles.checked,
                    this.eraseTiles.checked,
                    this.gridManager.infiniteGrid,
                );
                this.gridManager.drawGrid();
                // console.log(this.gridManager.cells);
            }

        }

        document.addEventListener('DOMContentLoaded', () => {
            new AutomataSimulator();
        });
    </script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Grid Drawing Simulator - Texture Based</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: rgba(10, 15, 30, 0.9);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.7);
            z-index: 10;
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
        }
        
        h1 {
            font-size: 1.8rem;
            margin-right: 20px;
            background: linear-gradient(90deg, #4a9eff, #6bffb8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #a0c8ff;
        }
        
        input, select, button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(20, 25, 45, 0.9);
            color: white;
            border: 1px solid rgba(74, 158, 255, 0.3);
        }
        
        button {
            background: linear-gradient(135deg, #4a9eff, #2d5bff);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: linear-gradient(135deg, #2d8cff, #1a4aff);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(45, 91, 255, 0.4);
        }
        
        .mode-buttons {
            display: flex;
            gap: 8px;
        }
        
        .mode-btn {
            padding: 8px 15px;
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ff2d2d);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 15, 30, 0.85);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 5;
            border: 1px solid rgba(74, 158, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .instructions h2 {
            margin-bottom: 10px;
            font-size: 1.2rem;
            color: #6bffb8;
        }
        
        .instructions ul {
            list-style-type: none;
        }
        
        .instructions li {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .instructions li:before {
            content: "â€¢";
            color: #4a9eff;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 15, 30, 0.85);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            z-index: 5;
            border: 1px solid rgba(74, 158, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .status div {
            margin-bottom: 5px;
        }
        
        .status span {
            color: #6bffb8;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }
            
            .controls {
                justify-content: center;
            }
            
            .instructions {
                max-width: 250px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>WebGL Grid Drawing Simulator - Texture Based</h1>
        <div class="controls">
            <div class="control-group">
                <label for="gridSize">Grid Size:</label>
                <input type="number" id="gridSize" min="5" max="500" value="50">
            </div>
            
            <div class="control-group">
                <label for="drawColor">Draw Color:</label>
                <input type="color" id="drawColor" value="#4a9eff">
            </div>
            
            <div class="control-group">
                <label for="bgColor">Background Color:</label>
                <input type="color" id="bgColor" value="#0a0a1a">
            </div>
            
            <div class="mode-buttons">
                <button id="panMode" class="mode-btn">Pan</button>
                <button id="drawMode" class="mode-btn active">Draw</button>
                <button id="eraseMode" class="mode-btn">Erase</button>
            </div>
            
            <button id="fillBtn">Fill All</button>
            <button id="clearBtn">Clear All</button>
            <button id="centerBtn">Center</button>
        </div>
    </div>
    
    <div class="canvas-container">
        <canvas id="gridCanvas"></canvas>
        
        <div class="instructions">
            <h2>Controls:</h2>
            <ul>
                <li><strong>Pan:</strong> Drag to move around the grid</li>
                <li><strong>Draw:</strong> Click and drag to fill cells</li>
                <li><strong>Erase:</strong> Click and drag to clear cells</li>
                <li><strong>Zoom:</strong> Use mouse wheel to zoom in/out</li>
                <li><strong>Fill All:</strong> Completely fill the grid</li>
                <li><strong>Clear All:</strong> Reset the entire grid</li>
                <li><strong>Cell Size:</strong> Automatically adjusts with zoom</li>
            </ul>
        </div>
        
        <div class="status">
            <div>Mode: <span id="modeDisplay">Draw</span></div>
            <div>Zoom: <span id="zoomDisplay">100%</span></div>
            <div>Grid: <span id="gridDisplay">50x50</span></div>
            <div>Cell Size: <span id="cellSizeDisplay">20px</span></div>
            <div>FPS: <span id="fpsDisplay">60</span></div>
        </div>
    </div>

    <script>
        "use strict";

        class WebGLGridSimulator {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                
                // Initialize properties
                this.gridSize = 50;
                this.baseCellSize = 20; // Fixed base cell size in world coordinates
                this.grid = [];
                
                // Camera view in world coordinates
                this.cameraView = { 
                    camX: 0,  // World X offset
                    camY: 0,  // World Y offset  
                    zoom: 1   // Zoom factor
                };
                
                // Color properties
                this.drawColor = this.hexToRgb("#4a9eff");
                this.bgColor = this.hexToRgb("#0a0a1a");
                
                // Input state
                this.isDrawing = false;
                this.isPanning = false;
                this.currentMode = 'draw';
                this.lastWorldPos = null; // Track last position in world coordinates
                this.lastPanX = 0;
                this.lastPanY = 0;
                
                // Performance monitoring
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.fps = 60;
                
                // WebGL properties for texture-based approach
                this.program = null;
                this.vertexBuffer = null;
                this.indexBuffer = null;
                this.gridTexture = null;
                this.textureData = null;
                
                // Initialize WebGL and other components
                this.initWebGL();
                this.initGrid();
                this.setupEventListeners();
                this.centerView();
                this.updateGridTexture();
                this.drawGrid();
                this.updateStatus();
            }

            // Update the fragment shader to use normalized world coordinates
            initShaders() {
                const gl = this.gl;

                const vsSource = `
                    attribute vec2 aPosition;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        gl_Position = vec4(aPosition, 0.0, 1.0);
                        vTexCoord = aPosition * 0.5 + 0.5;
                    }
                `;

                const fsSource = `
                    precision mediump float;
                    uniform vec2 uResolution;
                    uniform vec2 uOffset;
                    uniform float uScale;
                    uniform float uGridSize;
                    uniform float uBaseCellSize;
                    uniform vec4 uDrawColor;
                    uniform vec4 uBgColor;
                    uniform sampler2D uGridTexture;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        // Convert to normalized world coordinates
                        vec2 worldPos = (vTexCoord * uResolution - uOffset) / uScale;
                        
                        // Calculate grid coordinates using base cell size (consistent at all zoom levels)
                        vec2 gridPos = floor(worldPos / uBaseCellSize);
                        
                        // Check if within grid bounds
                        if (gridPos.x >= 0.0 && gridPos.x < uGridSize && gridPos.y >= 0.0 && gridPos.y < uGridSize) {
                            // Sample from grid texture
                            vec2 texCoord = gridPos / uGridSize;
                            vec4 cellValue = texture2D(uGridTexture, texCoord);
                            
                            if (cellValue.r > 0.5) {
                                gl_FragColor = uDrawColor;
                            } else {
                                gl_FragColor = uBgColor;
                            }
                        } else {
                            // Outside grid bounds
                            gl_FragColor = uBgColor;
                        }
                    }
                `;

                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fsSource);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Shader program failed to link:', gl.getProgramInfoLog(this.program));
                }
            }

            // WebGL Renderer Methods - TEXTURE BASED
            initWebGL() {
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!this.gl) {
                    throw new Error("WebGL not supported");
                }
                
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.clearColor(0, 0, 0, 0);
                
                this.initShaders();
                this.initBuffers();
                this.updateCanvasSize();
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            initBuffers() {
                const gl = this.gl;
                
                // Create vertex buffer for full-screen quad
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                
                const vertices = new Float32Array([
                    -1.0, -1.0,  // bottom left
                    1.0, -1.0,   // bottom right
                    1.0, 1.0,    // top right
                    -1.0, 1.0    // top left
                ]);
                
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                // Create index buffer
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                
                // Create grid texture
                this.gridTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            }

            updateCanvasSize() {
                const width = window.innerWidth;
                const height = window.innerHeight - document.querySelector('.header').offsetHeight;
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.width = width;
                this.height = height;
                
                const gl = this.gl;
                gl.viewport(0, 0, width, height);
            }

            // Grid Management Methods - TEXTURE BASED
            initGrid() {
                this.grid = [];
                this.textureData = new Uint8Array(this.gridSize * this.gridSize * 4);
                
                for (let y = 0; y < this.gridSize; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.gridSize; x++) {
                        this.grid[y][x] = false;
                        this.setTexturePixel(x, y, [0, 0, 0, 0]);
                    }
                }
            }

            setTexturePixel(x, y, color) {
                const index = (y * this.gridSize + x) * 4;
                this.textureData[index] = color[0] * 255;     // R
                this.textureData[index + 1] = color[1] * 255; // G
                this.textureData[index + 2] = color[2] * 255; // B
                this.textureData[index + 3] = color[3] * 255; // A
            }

            updateGridTexture() {
                const gl = this.gl;
                
                // Update texture data based on grid state
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        if (this.grid[y][x]) {
                            this.setTexturePixel(x, y, [1, 1, 1, 1]); // White for filled cells
                        } else {
                            this.setTexturePixel(x, y, [0, 0, 0, 0]); // Black for empty cells
                        }
                    }
                }
                
                // Upload texture to GPU
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.gridSize, this.gridSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            fillGrid() {
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        this.grid[y][x] = true;
                    }
                }
                this.updateGridTexture();
            }

            toggleCell(x, y, mode) {
                if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                    const gl = this.gl;
                    
                    if (mode === 'draw') {
                        this.grid[y][x] = true;
                    } else if (mode === 'erase') {
                        this.grid[y][x] = false;
                    }
                    
                    // Update the texture - only the changed pixel
                    gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                    
                    const pixelData = new Uint8Array([
                        this.grid[y][x] ? 255 : 0,
                        this.grid[y][x] ? 255 : 0,
                        this.grid[y][x] ? 255 : 0,
                        255
                    ]);
                    
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
                    
                    return true;
                }
                return false;
            }

            resizeGrid(newSize) {
                const oldGrid = this.grid;
                const oldSize = this.gridSize;
                
                this.gridSize = newSize;
                this.initGrid();
                
                // Copy old grid data
                const minSize = Math.min(oldSize, newSize);
                for (let y = 0; y < minSize; y++) {
                    for (let x = 0; x < minSize; x++) {
                        this.grid[y][x] = oldGrid[y][x];
                    }
                }
                this.updateGridTexture();
                this.centerView();
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255,
                    1.0
                ] : [0.5, 0.5, 0.5, 1.0];
            }

            setMode(mode) {
                this.currentMode = mode;
                
                if (mode === 'pan') {
                    this.canvas.style.cursor = 'grab';
                } else {
                    this.canvas.style.cursor = 'crosshair';
                }
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.updateCanvasSize();
                });
                
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startAction(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', () => this.stopAction());
                this.canvas.addEventListener('mouseleave', () => this.stopAction());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startAction(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleMove(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', () => this.stopAction());
                
                // Zoom with mouse wheel
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    this.zoomAt(zoomFactor, x, y);
                    this.updateStatus();
                });
                
                // Control panel events
                document.getElementById('gridSize').addEventListener('change', (e) => {
                    const newSize = parseInt(e.target.value);
                    this.resizeGrid(newSize);
                    this.updateStatus();
                });
                
                document.getElementById('drawColor').addEventListener('change', (e) => {
                    const hex = e.target.value;
                    this.drawColor = this.hexToRgb(hex);
                });
                
                document.getElementById('bgColor').addEventListener('change', (e) => {
                    const hex = e.target.value;
                    this.bgColor = this.hexToRgb(hex);
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.initGrid();
                    this.updateGridTexture();
                });
                
                document.getElementById('fillBtn').addEventListener('click', () => {
                    this.fillGrid();
                    this.updateGridTexture();
                });
                
                document.getElementById('centerBtn').addEventListener('click', () => {
                    this.centerView();
                    this.updateStatus();
                });
                
                // Mode buttons
                document.getElementById('panMode').addEventListener('click', () => {
                    this.setMode('pan');
                    this.updateModeButtons('pan');
                    this.updateStatus();
                });
                
                document.getElementById('drawMode').addEventListener('click', () => {
                    this.setMode('draw');
                    this.updateModeButtons('draw');
                    this.updateStatus();
                });
                
                document.getElementById('eraseMode').addEventListener('click', () => {
                    this.setMode('erase');
                    this.updateModeButtons('erase');
                    this.updateStatus();
                });
            }

            // Main Application Methods
            updateModeButtons(activeMode) {
                document.getElementById('panMode').classList.toggle('active', activeMode === 'pan');
                document.getElementById('drawMode').classList.toggle('active', activeMode === 'draw');
                document.getElementById('eraseMode').classList.toggle('active', activeMode === 'erase');
            }

            // Continuous rendering loop for texture-based approach
            drawGrid() {
                const gl = this.gl;
                
                // Clear the canvas with background color
                gl.clearColor(this.bgColor[0], this.bgColor[1], this.bgColor[2], this.bgColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Use the shader program
                gl.useProgram(this.program);
                
                // Set up vertex buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                const positionAttribute = gl.getAttribLocation(this.program, 'aPosition');
                gl.enableVertexAttribArray(positionAttribute);
                gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);
                
                // Set up index buffer
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                // Set uniforms
                const resolutionUniform = gl.getUniformLocation(this.program, 'uResolution');
                gl.uniform2f(resolutionUniform, this.canvas.width, this.canvas.height);
                
                const offsetUniform = gl.getUniformLocation(this.program, 'uOffset');
                gl.uniform2f(offsetUniform, this.cameraView.camX, this.cameraView.camY);
                
                const scaleUniform = gl.getUniformLocation(this.program, 'uScale');
                gl.uniform1f(scaleUniform, this.cameraView.zoom);
                
                const gridSizeUniform = gl.getUniformLocation(this.program, 'uGridSize');
                gl.uniform1f(gridSizeUniform, this.gridSize);
                
                const baseCellSizeUniform = gl.getUniformLocation(this.program, 'uBaseCellSize');
                gl.uniform1f(baseCellSizeUniform, this.baseCellSize);
                
                const drawColorUniform = gl.getUniformLocation(this.program, 'uDrawColor');
                gl.uniform4fv(drawColorUniform, this.drawColor);
                
                const bgColorUniform = gl.getUniformLocation(this.program, 'uBgColor');
                gl.uniform4fv(bgColorUniform, this.bgColor);
                
                // Bind texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                const textureUniform = gl.getUniformLocation(this.program, 'uGridTexture');
                gl.uniform1i(textureUniform, 0);
                
                // Draw the full-screen quad
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                
                // Update FPS counter
                this.updateFPS();
                
                // Request next frame - continuous rendering
                requestAnimationFrame(() => this.drawGrid());
            }

            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                
                if (now >= this.lastFpsUpdate + 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                    
                    document.getElementById('fpsDisplay').textContent = this.fps;
                }
            }

            updateStatus() {
                document.getElementById('modeDisplay').textContent = 
                    this.currentMode.charAt(0).toUpperCase() + 
                    this.currentMode.slice(1);
                document.getElementById('zoomDisplay').textContent = 
                    Math.round(this.cameraView.zoom * 100) + '%';
                document.getElementById('gridDisplay').textContent = 
                    this.gridSize + 'x' + this.gridSize;
                document.getElementById('cellSizeDisplay').textContent = 
                    Math.round(this.baseCellSize * this.cameraView.zoom) + 'px';
            }

            // Normalized coordinate conversion methods
            screenToWorld(screenX, screenY) {
                // Convert screen coordinates to normalized world coordinates
                const worldX = (screenX - this.cameraView.camX) / this.cameraView.zoom;
                const worldY = (screenY - this.cameraView.camY) / this.cameraView.zoom;
                return { x: worldX, y: worldY };
            }

            worldToScreen(worldX, worldY) {
                // Convert world coordinates back to screen coordinates
                const screenX = worldX * this.cameraView.zoom + this.cameraView.camX;
                const screenY = worldY * this.cameraView.zoom + this.cameraView.camY;
                return { x: screenX, y: screenY };
            }

            worldToCell(worldX, worldY) {
                // Convert world coordinates to grid cell coordinates
                const gridX = Math.floor(worldX / this.baseCellSize);
                const gridY = Math.floor(worldY / this.baseCellSize);
                
                if (gridX >= 0 && gridX < this.gridSize && gridY >= 0 && gridY < this.gridSize) {
                    return [gridX, gridY];
                }
                return null;
            }

            screenToCell(screenX, screenY) {
                // Convert screen coordinates directly to grid cell coordinates
                const world = this.screenToWorld(screenX, screenY);
                return this.worldToCell(world.x, world.y);
            }

            cellToWorld(cellX, cellY) {
                // Convert grid cell coordinates to world coordinates (center of cell)
                const worldX = cellX * this.baseCellSize + this.baseCellSize / 2;
                const worldY = cellY * this.baseCellSize + this.baseCellSize / 2;
                return { x: worldX, y: worldY };
            }

            cellToScreen(cellX, cellY) {
                // Convert grid cell coordinates to screen coordinates
                const world = this.cellToWorld(cellX, cellY);
                return this.worldToScreen(world.x, world.y);
            }

            // Input Handler Methods with normalized coordinates
            startAction(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                if (this.currentMode === 'pan') {
                    this.isPanning = true;
                    this.lastPanX = e.clientX;
                    this.lastPanY = e.clientY;
                    this.canvas.style.cursor = 'grabbing';
                } else {
                    this.isDrawing = true;
                    const cell = this.screenToCell(screenX, screenY);
                    if (cell) {
                        this.toggleCell(cell[0], cell[1], this.currentMode);
                        // Store the world position for continuous drawing
                        this.lastWorldPos = this.screenToWorld(screenX, screenY);
                    }
                }
            }

            handleMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                if (this.isPanning) {
                    const dx = e.clientX - this.lastPanX;
                    const dy = e.clientY - this.lastPanY;
                    this.pan(dx, dy);
                    this.lastPanX = e.clientX;
                    this.lastPanY = e.clientY;
                } else if (this.isDrawing) {
                    const currentWorldPos = this.screenToWorld(screenX, screenY);
                    const cell = this.worldToCell(currentWorldPos.x, currentWorldPos.y);
                    
                    if (cell) {
                        this.toggleCell(cell[0], cell[1], this.currentMode);
                        
                        // For continuous drawing, interpolate between last and current world positions
                        if (this.lastWorldPos) {
                            this.drawLineBetweenPoints(this.lastWorldPos, currentWorldPos);
                        }
                        
                        this.lastWorldPos = currentWorldPos;
                    }
                }
            }

            drawLineBetweenPoints(startWorld, endWorld) {
                // Interpolate between two world points and draw all cells along the line
                const distance = Math.sqrt(
                    Math.pow(endWorld.x - startWorld.x, 2) + 
                    Math.pow(endWorld.y - startWorld.y, 2)
                );
                
                const steps = Math.max(1, Math.ceil(distance / (this.baseCellSize * 0.5)));
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const interpWorldX = startWorld.x + (endWorld.x - startWorld.x) * t;
                    const interpWorldY = startWorld.y + (endWorld.y - startWorld.y) * t;
                    
                    const cell = this.worldToCell(interpWorldX, interpWorldY);
                    if (cell) {
                        this.toggleCell(cell[0], cell[1], this.currentMode);
                    }
                }
            }

            stopAction() {
                this.isDrawing = false;
                this.isPanning = false;
                this.lastWorldPos = null;
                
                if (this.currentMode === 'pan') {
                    this.canvas.style.cursor = 'grab';
                } else {
                    this.canvas.style.cursor = 'crosshair';
                }
            }

            // Camera Controller Methods with normalized coordinates
            centerView() {
                // Center the view on the grid in world coordinates
                const gridWorldWidth = this.gridSize * this.baseCellSize;
                const gridWorldHeight = this.gridSize * this.baseCellSize;
                
                this.cameraView.camX = (this.canvas.width - gridWorldWidth) / 2;
                this.cameraView.camY = (this.canvas.height - gridWorldHeight) / 2;
                this.cameraView.zoom = 1;
            }

            zoomAt(factor, screenX, screenY) {
                const newZoom = this.cameraView.zoom * factor;
                
                if (newZoom < 0.001 || newZoom > 10) return;
                
                // Get the world position under the cursor before zooming
                const worldBeforeZoom = this.screenToWorld(screenX, screenY);
                
                // Update zoom
                this.cameraView.zoom = newZoom;
                
                // Get the screen position that should correspond to the same world position after zooming
                const screenAfterZoom = this.worldToScreen(worldBeforeZoom.x, worldBeforeZoom.y);
                
                // Adjust camera to maintain the same world position under the cursor
                this.cameraView.camX += screenX - screenAfterZoom.x;
                this.cameraView.camY += screenY - screenAfterZoom.y;
            }

            pan(dx, dy) {
                // Pan in screen coordinates (dx, dy are screen space deltas)
                this.cameraView.camX += dx;
                this.cameraView.camY += dy;
            }

        }

        // Initialize the simulator when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new WebGLGridSimulator('gridCanvas');
        });
    </script>
</body>
</html>
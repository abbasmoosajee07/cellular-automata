<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Cellular Automata</title>

    <!-- SEO -->
    <meta name="description" content="Interactive cellular automata simulator â€” Chaos disguised as order.">
    <meta name="keywords" content="cellular automata, game of life, conway, life">
    <meta name="robots" content="index, follow">

    <!-- Icons -->
    <link rel="icon" href="./assets/LOGO.png" type="image/x-icon">
    <link rel="shortcut icon" href="./assets/LOGO.png">
    <link rel="apple-touch-icon" href="./assets/LOGO.png">

    <!-- Styles & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="./styles.css">

</head>

<body>
    <!-- Toggle Button -->
    <button id="menuToggle" class="toggle-panel-btn">
        <i class="bi bi-three-dots-vertical"></i>
    </button>

    <!-- Collapsible Side Panel -->
    <div class="sidenav" id="menuPanel">
        <!-- Vertical Tabs on the left -->
        <div class="sidenav-tabs">
            <button class="tab-btn active" data-panel="aboutPanel">
                <i class="bi bi-info-circle-fill"></i>
            </button>
            <button class="tab-btn" data-panel="gridPanel" title="Grid Controls">
                <i class="bi bi-grid-3x3-gap-fill"></i>
            </button>
            <button class="tab-btn" data-panel="drawPanel">
                <i class="bi bi-pencil-fill"></i>
            </button>
            <button class="tab-btn" data-panel="logicPanel" title="Automata Logic">
                <i class="bi bi-cpu-fill"></i>
            </button>
            <button class="tab-btn" data-panel="statsPanel" title="Statistics">
                <i class="bi bi-graph-up"></i>
            </button>
        </div>

        <!-- Panel Content -->
        <div class="sidenav-panels">
            <!-- About Panel -->
            <div class="panel active" id="aboutPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-info-circle-fill me-2"></i> Cellular Automaton</h3>
                </div>
                <div class="container">
                    <!-- Your main panel content here -->

                    <!-- Footer section at bottom of panel -->
                    <div class="mt-auto pt-3 border-top">
                        <div class="mb-2">
                            &copy; <span id="year"></span> Abbas Moosajee &nbsp;|&nbsp;
                            <a href="https://github.com/abbasmoosajee07/cellular-automata" target="_blank" title="View Source Code" class="text-dark text-decoration-none">
                                <i class="bi bi-github align-middle"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Grid Panel -->
            <div class="panel" id="gridPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-grid-3x3-gap-fill me-2"></i> Grid Controls</h3>
                </div>
                <button class="action-btn" id="themeToggle" aria-label="Toggle theme">
                    <span id="themeText" class="ms-2"></span>
                    <i id="themeIcon" class="bi"></i>
                </button>

                <div class="config-group">
                    <h3>Cell Shapes:</h3>
                    <div class="config-row">
                        <div class="config-option">
                            <input type="radio" id="shape-hex" name="shape" value="hex">
                            <label for="shape-hex">Hexagons</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="shape-triangle" name="shape" value="triangle">
                            <label for="shape-triangle">Triangle</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="shape-square" name="shape" value="square" checked>
                            <label for="shape-square">Square</label>
                        </div>
                    </div>
                </div>

                <div class="config-group">
                    <h3>Neighbor Rules</h3>
                    <div class="config-row">
                        <div class="config-option">
                            <input type="radio" id="neighbors-adjacent" name="neighbors" value="adjacent" checked>
                            <label for="neighbors-adjacent">Adjacent Only</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="neighbors-touching" name="neighbors" value="touching">
                            <label for="neighbors-touching">All Touching</label>
                        </div>
                    </div>
                </div>

                <div class="config-group">
                    <h3>Boundary Behavior</h3>
                    <div class="config-row">
                        <div class="config-option">
                            <input type="radio" id="bounds-infinite" name="bounds" value="infinite">
                            <label for="bounds-infinite">Infinite</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="bounds-wrap" name="bounds" value="wrap-around" checked>
                            <label for="bounds-wrap">Wrap-around</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="bounds-bounded" name="bounds" value="bounded">
                            <label for="bounds-bounded">Bounded</label>
                        </div>
                        <div class="config-option">
                            <input type="radio" id="bounds-cliff" name="bounds" value="cliff">
                            <label for="bounds-cliff">Fall off</label>
                        </div>
                    </div>
                </div>

                <div class="form-row">
                    <label for="colInput">Cols:</label>
                    <input type="number" class="grid-size-in" id="colInput" min="1" value="20" step="1">
                </div>

                <div class="form-row">
                    <label for="rowInput">Rows:</label>
                    <input type="number" class="grid-size-in" id="rowInput" min="1" value="20" step="1">
                </div>
            </div>

            <!-- Draw Panel -->
            <div class="panel" id="drawPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-pencil-fill me-2"></i> Drawing Tools</h3>
                </div>

                <div class="form-row">
                    <label for="drawTiles">Draw Tiles</label>
                    <input type="checkbox" id="drawTiles">
                </div>

                <div class="form-row">
                    <label for="eraseTiles">Erase Tiles</label>
                    <input type="checkbox" id="eraseTiles">
                </div>

                <button id="clearGrid" class="action-btn" title="Clear">
                    <i class="bi bi-trash-fill"></i> Clear
                </button>

                <button id="randomFill" class="action-btn" title="Random">
                    <i class="bi bi-shuffle"></i> Random
                </button>
                <button id="neighborTiles" class="action-btn" title="Add Neighbors">
                    <i class="bi bi-bounding-box"></i> Neighbor Tiles
                </button>
            </div>

            <!-- Logic Panel -->
            <div class="panel" id="logicPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-cpu-fill me-2"></i> Automata Logic</h3>
                </div>
                <!-- Add your logic panel content here -->
            </div>

            <!-- Stats Panel -->
            <div class="panel" id="statsPanel">
                <div class="panel-header">
                    <h3><i class="bi bi-graph-up me-2"></i> Statistics</h3>
                </div>
                <!-- Add your stats panel content here -->
            </div>
        </div>
    </div>

    <!-- Main Canvas -->
    <canvas id="gridCanvas"></canvas>

    <div class="control-panel">
        <button id="resetView" class="control-btn" title="Reset View">
            <i class="bi bi-camera-video-fill"></i>
        </button>

        <button id="pinLoc" class="control-btn" title="Pin Location">
            <i class="bi bi-pin-map-fill"></i>
        </button>

        <button id="simCtrl" class="control-btn" title="Pin Location">
            <i class="bi bi-play-fill"></i>
        </button>
    </div>

    <script src="./scripts/utils.js"></script>
    <script>
        class WebGLRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = this.initWebGL();
                if (!this.gl) {
                    throw new Error("WebGL not supported");
                }

                this.initShaders();
                this.initBuffers();
                this.updateCanvasSize();
                
                this.cachedGeometry = null;
            }

            initWebGL() {
                const gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!gl) {
                    console.error('WebGL not supported');
                    return null;
                }
                
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0, 0, 0, 0);
                
                return gl;
            }

            initShaders() {
                const gl = this.gl;

                const vsSource = `
                    attribute vec2 aPosition;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        gl_Position = vec4(aPosition, 0.0, 1.0);
                        vTexCoord = aPosition * 0.5 + 0.5;
                    }
                `;

                const fsSource = `
                    precision mediump float;
                    uniform vec2 uResolution;
                    uniform vec2 uOffset;
                    uniform float uScale;
                    uniform float uGridSize;
                    uniform float uBaseCellSize;
                    uniform vec4 uDrawColor;
                    uniform vec4 uBgColor;
                    uniform sampler2D uGridTexture;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        // Convert to world coordinates (centered at 0,0)
                        vec2 worldPos = (vTexCoord * uResolution - uResolution * 0.5 - uOffset) / uScale;
                        
                        // Calculate grid coordinates using base cell size
                        // Grid is centered at (0,0) in world space
                        float halfGridWorld = uGridSize * uBaseCellSize * 0.5;
                        vec2 gridPos = floor((worldPos + halfGridWorld) / uBaseCellSize);
                        
                        // Check if within grid bounds
                        if (gridPos.x >= 0.0 && gridPos.x < uGridSize && gridPos.y >= 0.0 && gridPos.y < uGridSize) {
                            // Sample from grid texture
                            vec2 texCoord = gridPos / uGridSize;
                            vec4 cellValue = texture2D(uGridTexture, texCoord);
                            
                            if (cellValue.a > 0.5) {
                                gl_FragColor = uDrawColor;
                            } else {
                                gl_FragColor = uBgColor;
                            }
                        } else {
                            // Outside grid bounds
                            gl_FragColor = uBgColor;
                        }
                    }
                `;

                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fsSource);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Shader program failed to link:', gl.getProgramInfoLog(this.program));
                }

                this.attribLocations = {
                    position: gl.getAttribLocation(this.program, 'aPosition')
                };

                this.uniformLocations = {
                    resolution: gl.getUniformLocation(this.program, 'uResolution'),
                    offset: gl.getUniformLocation(this.program, 'uOffset'),
                    scale: gl.getUniformLocation(this.program, 'uScale'),
                    gridSize: gl.getUniformLocation(this.program, 'uGridSize'),
                    baseCellSize: gl.getUniformLocation(this.program, 'uBaseCellSize'),
                    drawColor: gl.getUniformLocation(this.program, 'uDrawColor'),
                    bgColor: gl.getUniformLocation(this.program, 'uBgColor'),
                    gridTexture: gl.getUniformLocation(this.program, 'uGridTexture')
                };
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            initBuffers() {
                const gl = this.gl;
                
                // Create vertex buffer for full-screen quad
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                
                const vertices = new Float32Array([
                    -1.0, -1.0,  // bottom left
                    1.0, -1.0,   // bottom right
                    1.0, 1.0,    // top right
                    -1.0, 1.0    // top left
                ]);
                
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                // Create index buffer
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            }

            updateCanvasSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.width = width;
                this.height = height;
                
                const gl = this.gl;
                gl.viewport(0, 0, width, height);
            }

            uploadGeometry(geometry) {
                // For texture-based approach, geometry is always the same (full-screen quad)
                this.cachedGeometry = geometry;
            }

            draw(cameraView, gridGeometry, drawColor, bgColor) {
                const gl = this.gl;
                
                if (!gridGeometry || !gridGeometry.texture) {
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    return;
                }

                // Clear the canvas
                gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Use the shader program
                gl.useProgram(this.program);
                
                // Set up vertex buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.enableVertexAttribArray(this.attribLocations.position);
                gl.vertexAttribPointer(this.attribLocations.position, 2, gl.FLOAT, false, 0, 0);
                
                // Set up index buffer
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                // Set uniforms
                gl.uniform2f(this.uniformLocations.resolution, this.width, this.height);
                gl.uniform2f(this.uniformLocations.offset, cameraView.camX, cameraView.camY);
                gl.uniform1f(this.uniformLocations.scale, cameraView.zoom);
                gl.uniform1f(this.uniformLocations.gridSize, gridGeometry.gridSize);
                gl.uniform1f(this.uniformLocations.baseCellSize, gridGeometry.baseCellSize);
                gl.uniform4fv(this.uniformLocations.drawColor, drawColor);
                gl.uniform4fv(this.uniformLocations.bgColor, bgColor);
                
                // Bind texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, gridGeometry.texture);
                gl.uniform1i(this.uniformLocations.gridTexture, 0);
                
                // Draw the full-screen quad
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }
        }

        class SquareGrid {
            constructor(colorSchema, detailed, simple) {
                this.colorSchema = colorSchema;
                this.DETAILED_GRID_SIZE = detailed;
                this.SIMPLIFIED_GRID_SIZE = simple;
                this.radius = 30;
                this.zoom = 1;
                this.baseCellSize = 60; // 30 radius * 2
                
                // Texture properties
                this.gridTexture = null;
                this.textureData = null;
                this.gridSize = 50; // Default grid size
            }

            initGridTexture(gl, gridSize) {
                this.gridSize = gridSize;
                this.textureData = new Uint8Array(gridSize * gridSize * 4);
                
                // Initialize texture data to empty
                for (let i = 0; i < gridSize * gridSize * 4; i += 4) {
                    this.textureData[i] = 0;     // R
                    this.textureData[i + 1] = 0; // G
                    this.textureData[i + 2] = 0; // B
                    this.textureData[i + 3] = 0; // A (0 = transparent)
                }
                
                // Create WebGL texture
                this.gridTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gridSize, gridSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            resizeGridTexture(gl, newGridSize, oldCells) {
                // Save current texture data
                const oldData = this.textureData;
                const oldSize = this.gridSize;
                
                // Create new texture with new size
                this.initGridTexture(gl, newGridSize);
                
                // Copy old cell data to new texture
                if (oldCells && oldData) {
                    for (let y = 0; y < Math.min(oldSize, newGridSize); y++) {
                        for (let x = 0; x < Math.min(oldSize, newGridSize); x++) {
                            const oldIndex = (y * oldSize + x) * 4;
                            const newIndex = (y * newGridSize + x) * 4;
                            
                            // Check if cell was alive in old data
                            if (oldData[oldIndex + 3] > 0) {
                                this.setCellState(gl, x, y, true);
                            }
                        }
                    }
                }
            }

            updateGridTexture(gl) {
                if (!this.gridTexture) return;
                
                gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.gridSize, this.gridSize, gl.RGBA, gl.UNSIGNED_BYTE, this.textureData);
            }

            setCellState(gl, x, y, state) {
                if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                    const index = (y * this.gridSize + x) * 4;
                    
                    if (state) {
                        // Filled cell - use the color from schema
                        const color = this.colorSchema[1] || [1, 1, 1, 1];
                        this.textureData[index] = color[0] * 255;     // R
                        this.textureData[index + 1] = color[1] * 255; // G
                        this.textureData[index + 2] = color[2] * 255; // B
                        this.textureData[index + 3] = 255;            // A
                    } else {
                        // Empty cell - transparent
                        this.textureData[index] = 0;
                        this.textureData[index + 1] = 0;
                        this.textureData[index + 2] = 0;
                        this.textureData[index + 3] = 0;
                    }
                    
                    // Update single pixel in texture
                    gl.bindTexture(gl.TEXTURE_2D, this.gridTexture);
                    const pixelData = new Uint8Array([
                        this.textureData[index],
                        this.textureData[index + 1],
                        this.textureData[index + 2],
                        this.textureData[index + 3]
                    ]);
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
                    
                    return true;
                }
                return false;
            }

            fillGrid(gl) {
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        this.setCellState(gl, x, y, true);
                    }
                }
            }

            clearGrid(gl) {
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        this.setCellState(gl, x, y, false);
                    }
                }
            }

            worldToCell(world) {
                const size = this.baseCellSize;
                // Convert from world coordinates to grid coordinates
                // World coordinates are centered at (0,0), grid coordinates start at (0,0) in top-left
                const halfGridSize = (this.gridSize * size) / 2;
                const cellX = Math.floor((world.x + halfGridSize) / size);
                const cellY = Math.floor((world.y + halfGridSize) / size);
                return [cellX, cellY];
            }

            calculateBounds(bounds) {
                const [minX, maxX, minY, maxY] = bounds;
                const size = this.baseCellSize;

                const minCol = Math.floor(minX / size) - 1;
                const maxCol = Math.ceil(maxX / size) + 1;
                const minRow = Math.floor(minY / size) - 1;
                const maxRow = Math.ceil(maxY / size) + 1;

                return [minCol, maxCol, minRow, maxRow];
            }

            getGridGeometry(bounds, cells, maxCols, maxRows, infinite, gl) {
                // For texture-based approach, we don't need geometry
                // The entire grid is rendered with a full-screen quad
                return {
                    texture: this.gridTexture,
                    gridSize: this.gridSize,
                    baseCellSize: this.baseCellSize,
                    vertexCount: 4, // Full-screen quad
                    indexCount: 6   // Two triangles
                };
            }
        }

        class GridManager {
            adj_neighbors = [[0, -1], [0, 1], [1, 0], [-1, 0]];

            constructor1(shape, canvas, init_cells = new Map(), useWebGL = true) {
                this.shape = shape.value || shape;
                this.canvas = canvas;
                this.useWebGL = useWebGL;
                this.cells = init_cells;
                this.neighborsMap = new Map();

                // Grid defaults
                this.gridRows = 20;
                this.gridCols = 20;
                this.infiniteGrid = false;
                this.boundaryType = "wrap";
                this.neighborType = "adjacent";

                // Performance settings
                this.detail = 1;
                this.simple = 2;

                // Camera & colors
                this.cameraView = { camX: 0, camY: 0, zoom: 1 };
                this.colorSchema = {
                    line: this.hexToRgb("#555555"),
                    1: this.hexToRgb("#32cd32"),
                };
                this.drawColor = this.colorSchema[1];
                this.bgColor = this.hexToRgb("#0a0a1a");

                // Initialize shape-specific grid
                this.shapeGrid = this.createShapeGrid(this.shape);
                
                // Initialize WebGL renderer and texture
                this.initializeRenderer(this.useWebGL);
                this.shapeGrid.initGridTexture(this.renderer.gl, this.gridCols);
                
                // Sync existing cells to texture
                this.syncCellsToTexture();
                
                this.updateCanvasSize();
                
                // Start continuous rendering
                this.startRendering();
            }

            createShapeGrid(shape) {
                const { colorSchema, detail, simple } = this;
                switch (shape) {
                    case "square":   return new SquareGrid(colorSchema, detail, simple);
                    default:
                        throw new Error(`Unknown grid shape: ${shape}`);
                }
            }

            initializeRenderer(useWebGL) {
                try {
                    if (useWebGL) {
                        this.renderer = new WebGLRenderer(this.canvas);
                        console.log("Using WebGL texture-based renderer");
                    } else {
                        throw new Error("Canvas2D not implemented for texture approach");
                    }
                } catch (error) {
                    console.warn("WebGL not supported:", error);
                    throw error; // No fallback for texture-based approach
                }
            }

            syncCellsToTexture() {
                // Sync existing cells data to texture
                for (const [col, colMap] of this.cells) {
                    for (const [row, state] of colMap) {
                        if (state) {
                            this.shapeGrid.setCellState(this.renderer.gl, col, row, state);
                        }
                    }
                }
            }

            startRendering() {
                const renderLoop = () => {
                    this.drawGrid();
                    requestAnimationFrame(renderLoop);
                };
                renderLoop();
            }

            // FIXED: Proper screen to world coordinate conversion
            screenToWorld(px, py) {
                // Convert screen coordinates to world coordinates
                // Screen: (0,0) at top-left, (width,height) at bottom-right
                // World: (0,0) at center, positive Y up
                const worldX = (px - this.width / 2 - this.cameraView.camX) / this.cameraView.zoom;
                const worldY = (this.height / 2 - py - this.cameraView.camY) / this.cameraView.zoom; // Flip Y axis
                return { x: worldX, y: worldY };
            }

            worldToCell(world) {
                return this.shapeGrid.worldToCell(world);
            }

            // FIXED: Direct screen to cell conversion for better accuracy
            screenToCell(px, py) {
                const world = this.screenToWorld(px, py);
                return this.worldToCell(world);
            }

            setBoundaryType(boundaryType) {
                this.boundaryType = boundaryType;
                this.infiniteGrid = (boundaryType === "infinite");
            }

            getNeighbors(x, y) {
                const neighbors = [];
                for (const [dx, dy] of this.adj_neighbors) {
                    const nx = dx + x;
                    const ny = dy + y;
                    neighbors.push([nx, ny]);
                }
                return neighbors;
            }

            buildNeighborsMap() {
                const neighborsMap = new Map();
                const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                for (let c = minCol; c <= maxCol; c++) {
                    for (let r = minRow; r <= maxRow; r++) {
                        const cellNeighbors = this.getNeighbors(c, r)
                        neighborsMap.set([c, r], cellNeighbors);
                    }
                }
                console.log("Neighbors dict", neighborsMap);
            }

            addNeighbors(x, y) {
                const valid_neighbors = this.getNeighbors(x, y);
                this.neighborsMap.set([x, y], valid_neighbors)
            }

            randomCells() {
                const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                console.log(minCol, maxCol, minRow, maxRow);
                for (let c = minCol; c <= maxCol; c++) {
                    for (let r = minRow; r <= maxRow; r++) {
                        const status = Math.random() < 0.05 ? 0 : 1;
                        this.changeCell(c, r, status);
                    }
                }
            }

            updateCanvasSize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.canvas.width = width;
                this.canvas.height = height;
                this.width = width;
                this.height = height;

                if (this.renderer && this.renderer.updateCanvasSize) {
                    this.renderer.updateCanvasSize();
                }
            }

            getVisibleBounds() {
                const halfW = this.width / (2 * this.cameraView.zoom);
                const halfH = this.height / (2 * this.cameraView.zoom);

                const minWorldX = -this.cameraView.camX / this.cameraView.zoom - halfW;
                const maxWorldX = -this.cameraView.camX / this.cameraView.zoom + halfW;
                const minWorldY = -this.cameraView.camY / this.cameraView.zoom - halfH;
                const maxWorldY = -this.cameraView.camY / this.cameraView.zoom + halfH;

                return [minWorldX, maxWorldX, minWorldY, maxWorldY];
            }

            drawGrid() {
                const bounds = this.getVisibleBounds();
                const geometry = this.shapeGrid.getGridGeometry(
                    bounds, this.cells, this.gridCols, this.gridRows, this.infiniteGrid, this.renderer.gl
                );

                if (this.useWebGL) {
                    this.renderer.uploadGeometry(geometry);
                    this.renderer.draw(this.cameraView, geometry, this.drawColor, this.bgColor);
                }
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255,
                    1.0
                ] : [0.5, 0.5, 0.5, 1.0];
            }

            changeCell(x, y, state) {
                if (!this.cells.has(x)) this.cells.set(x, new Map());
                this.cells.get(x).set(y, state);
                
                // Update texture
                this.shapeGrid.setCellState(this.renderer.gl, x, y, state);
                
                this.addNeighbors(x, y);
            }

            getBounds() {
                const cols = Number(this.gridCols) || 0;
                const rows = Number(this.gridRows) || 0;

                const minCol = 0;
                const maxCol = cols - 1;
                const minRow = 0;
                const maxRow = rows - 1;

                return [minCol, maxCol, minRow, maxRow];
            }

            checkBounds(x, y) {
                if (!this.infiniteGrid) {
                    const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                    if (x < minCol || x > maxCol || y < minRow || y > maxRow) {
                        return false;
                    }
                }
                return true;
            }

            toggleAt(px, py, drawMode, eraseMode) {
                // Use direct screen to cell conversion for better accuracy
                const cell = this.screenToCell(px, py);
                if (!cell) return false;

                const [x, y] = cell;

                if (!this.checkBounds(x, y)) return false;

                let newState;
                if (drawMode) {
                    newState = 1;
                } else if (eraseMode) {
                    newState = 0;
                } else {
                    // safer check: ensure y exists in nested Map
                    const currentState = (this.cells.has(x) && this.cells.get(x).has(y)) ? this.cells.get(x).get(y) : 0;
                    newState = currentState ? 0 : 1;
                }

                this.changeCell(x, y, newState);
                return true;
            }

            fillAll() {
                this.shapeGrid.fillGrid(this.renderer.gl);
                // Also update the cells map
                const [minCol, maxCol, minRow, maxRow] = this.getBounds();
                for (let c = minCol; c <= maxCol; c++) {
                    for (let r = minRow; r <= maxRow; r++) {
                        if (!this.cells.has(c)) this.cells.set(c, new Map());
                        this.cells.get(c).set(r, 1);
                    }
                }
            }

            clearAll() {
                this.shapeGrid.clearGrid(this.renderer.gl);
                this.cells.clear();
            }

            // Add method for continuous drawing
            drawLineBetweenPoints(startWorld, endWorld, mode) {
                const startCell = this.worldToCell(startWorld);
                const endCell = this.worldToCell(endWorld);
                
                if (!startCell || !endCell) return;

                const [x1, y1] = startCell;
                const [x2, y2] = endCell;

                // Simple line drawing algorithm
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;

                let x = x1;
                let y = y1;

                while (true) {
                    if (this.checkBounds(x, y)) {
                        const state = (mode === 'draw') ? 1 : 0;
                        this.changeCell(x, y, state);
                    }

                    if (x === x2 && y === y2) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
            }

            constructor(shape, canvas, init_cells = new Map(), useWebGL = true) {
                this.shape = shape.value || shape;
                this.canvas = canvas;
                this.useWebGL = useWebGL;
                this.cells = init_cells;
                this.neighborsMap = new Map();

                // Grid defaults
                this.gridRows = 20;
                this.gridCols = 20;
                this.infiniteGrid = false;
                this.boundaryType = "wrap";
                this.neighborType = "adjacent";

                // Performance settings
                this.detail = 1;
                this.simple = 2;

                // Camera & colors
                this.cameraView = { camX: 0, camY: 0, zoom: 1 };
                this.colorSchema = {
                    line: this.hexToRgb("#555555"),
                    1: this.hexToRgb("#32cd32"),
                };
                this.drawColor = this.colorSchema[1];
                this.bgColor = this.hexToRgb("#0a0a1a");

                // Initialize shape-specific grid
                this.shapeGrid = this.createShapeGrid(this.shape);
                
                // Initialize WebGL renderer and texture
                this.initializeRenderer(this.useWebGL);
                this.shapeGrid.initGridTexture(this.renderer.gl, this.gridCols);
                
                // Sync existing cells to texture
                this.syncCellsToTexture();
                
                this.updateCanvasSize();
                
                // Start continuous rendering
                this.startRendering();
            }

            createShapeGrid(shape) {
                const { colorSchema, detail, simple } = this;
                switch (shape) {
                    case "square":   return new SquareGrid(colorSchema, detail, simple);
                    default:
                        throw new Error(`Unknown grid shape: ${shape}`);
                }
            }

            initializeRenderer(useWebGL) {
                try {
                    if (useWebGL) {
                        this.renderer = new WebGLRenderer(this.canvas);
                        console.log("Using WebGL texture-based renderer");
                    } else {
                        throw new Error("Canvas2D not implemented for texture approach");
                    }
                } catch (error) {
                    console.warn("WebGL not supported:", error);
                    throw error; // No fallback for texture-based approach
                }
            }

            syncCellsToTexture() {
                // Sync existing cells data to texture
                for (const [col, colMap] of this.cells) {
                    for (const [row, state] of colMap) {
                        if (state && col < this.gridCols && row < this.gridRows) {
                            this.shapeGrid.setCellState(this.renderer.gl, col, row, state);
                        }
                    }
                }
            }

            // NEW: Method to resize the grid
            resizeGrid(newCols, newRows) {
                const oldCols = this.gridCols;
                const oldRows = this.gridRows;
                
                this.gridCols = newCols;
                this.gridRows = newRows;
                
                // Save current cells data
                const oldCells = new Map();
                for (const [col, colMap] of this.cells) {
                    if (col < newCols) {
                        const newColMap = new Map();
                        for (const [row, state] of colMap) {
                            if (row < newRows && state) {
                                newColMap.set(row, state);
                            }
                        }
                        if (newColMap.size > 0) {
                            oldCells.set(col, newColMap);
                        }
                    }
                }
                
                // Resize the texture
                this.shapeGrid.resizeGridTexture(this.renderer.gl, newCols, oldCells);
                
                // Update cells with the resized data
                this.cells = oldCells;
                
                // Re-center the view
                this.centerView();
            }

            centerView() {
                // Center the view on the grid
                const gridWorldWidth = this.gridCols * this.shapeGrid.baseCellSize;
                const gridWorldHeight = this.gridRows * this.shapeGrid.baseCellSize;
                
                this.cameraView.camX = 0;
                this.cameraView.camY = 0;
                this.cameraView.zoom = 1;
            }

            startRendering() {
                const renderLoop = () => {
                    this.drawGrid();
                    requestAnimationFrame(renderLoop);
                };
                renderLoop();
            }

            // ... rest of the GridManager methods remain the same ...

            getBounds() {
                const cols = Number(this.gridCols) || 0;
                const rows = Number(this.gridRows) || 0;

                const minCol = 0;
                const maxCol = cols - 1;
                const minRow = 0;
                const maxRow = rows - 1;

                return [minCol, maxCol, minRow, maxRow];
            }

            // ... other methods remain unchanged ...
        }

        class AutomataSimulator{
            docIDs = [
                "gridCanvas", "menuPanel", "menuToggle", "drawTiles", "eraseTiles",
                "rowInput", "colInput", "resetView", "pinLoc", "clearGrid", "randomFill",
                "neighborTiles",
            ]

            constructor(){
                this.initElements();
                this.initGrid();
                this.setupGridControls()
                this.setupEventListeners();
                this.setupCanvasControls();
                this.setupMenuControls();
                this.gridManager.drawGrid();
            }

            initElements() {
                for (const id of this.docIDs) {
                    this[id] = document.getElementById(id);
                }
            }

            delElements() {
                this.docIDs.forEach(id => {
                    const elem = document.getElementById(id);
                    if (elem) {
                        const newElem = elem.cloneNode(true);
                        elem.parentNode.replaceChild(newElem, elem);
                    }
                });
            }

            setupMenuControls() {
                const panel = this.menuPanel;

                this.menuToggle.addEventListener('click', () => {
                panel.classList.toggle('open');
                });
                document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // deactivate all
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.sidenav-panels .panel').forEach(p => p.classList.remove('active'));

                    // activate chosen
                    btn.classList.add('active');
                    document.getElementById(btn.dataset.panel).classList.add('active');
                });
                });
            }

            initGrid() {
                this.gridManager = new GridManager("square", this.gridCanvas);
                this.savedView = { ...this.gridManager.cameraView };
                this.gridManager.gridRows = parseInt(this.rowInput.value);
                this.gridManager.gridCols = parseInt(this.colInput.value);
            }

            setupGridControls() {
                // Store references to all shape radio buttons
                this.shapeRadios = document.querySelectorAll('input[name="shape"]');
                this.shapeRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                            const selectedShape = radio.value;
                            const old_grid = this.gridManager

                            this.gridManager = new GridManager(selectedShape, this.gridCanvas, old_grid.cells);
                            this.gridManager.cameraView = { ...old_grid.cameraView };
                            this.gridManager.gridRows = old_grid.gridRows;
                            this.gridManager.gridCols = old_grid.gridCols;
                            this.gridManager.infiniteGrid = old_grid.infiniteGrid;
                            this.gridManager.drawGrid();
                        }
                    });
                });

                this.rowInput.addEventListener('input', () => {
                    const newRows = parseInt(this.rowInput.value);
                    const newCols = parseInt(this.colInput.value);
                    this.gridManager.resizeGrid(newCols, newRows);
                    this.gridManager.drawGrid();
                });

                this.colInput.addEventListener('input', () => {
                    const newRows = parseInt(this.rowInput.value);
                    const newCols = parseInt(this.colInput.value);
                    this.gridManager.resizeGrid(newCols, newRows);
                    this.gridManager.drawGrid();
                });

                // Store references to all neighbors radio buttons
                this.neighborsRadio = document.querySelectorAll('input[name="neighbors"]');
                // Add event listener to each radio button
                this.neighborsRadio.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                        };
                    });
                });

                // Store references to all boundary radio buttons
                this.boundsRadio = document.querySelectorAll('input[name="bounds"]');
                this.boundsRadio.forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                            this.gridManager.setBoundaryType(radio.value);
                            this.gridManager.drawGrid();
                        }
                    });
                });
            }

            setupEventListeners() {
                this.resetView.addEventListener('click', () => {
                    this.gridManager.cameraView = { ...this.savedView };
                    this.gridManager.drawGrid();
                });

                this.pinLoc.addEventListener('click', () => {
                    this.savedView = { ...this.gridManager.cameraView };
                });

                this.clearGrid.addEventListener('click', () => {
                    // use existing API so texture and internal state both cleared
                    this.gridManager.clearAll();
                    this.gridManager.drawGrid();
                });

                this.randomFill.addEventListener('click', () => this.gridManager.randomCells());

                window.addEventListener('resize', () => {
                    this.gridManager.updateCanvasSize();
                    this.gridManager.drawGrid();
                });

        this.neighborTiles.addEventListener('click', () => {
            const availCells = this.gridManager.cells;
            const neighborsToActivate = [];

            // Collect neighbors of all active cells
            for (const [col, colMap] of availCells) {
                for (const [row, cellData] of colMap) {
                    if (cellData === 1) { // expand only from alive cells
                        const neighborCells = this.gridManager.getNeighbors(col, row);
                        neighborsToActivate.push(...neighborCells); // just dump them in
                    }
                }
            }

            // Apply neighbor activation
            for (const [nc, nr] of neighborsToActivate) {
                this.gridManager.changeCell(nc, nr, 1);
            }

            this.gridManager.drawGrid();
        });


            }

            setupCanvasControls() {
                let painting = false;
                let draggingCam = false;
                let lastX = 0, lastY = 0;
                let lastTouchDistance = null;
                const MIN_ZOOM = 10;
                const MAX_ZOOM = 0.001;

                const getPointer = (e) => {
                    if (e.touches && e.touches.length > 0) {
                        return { x: e.touches[0].clientX, y: e.touches[0].clientY, touches: e.touches.length };
                    }
                    return { x: e.clientX, y: e.clientY, touches: 1 };
                };

                const handleDown = (pointer) => {
                    if (pointer.touches === 1) {
                        if (this.drawTiles.checked || this.eraseTiles.checked) {
                            painting = true;
                            this.toggleAt(pointer.x, pointer.y);
                        } else {
                            draggingCam = true;
                        }
                        lastX = pointer.x;
                        lastY = pointer.y;
                    } else if (pointer.touches === 2) {
                        painting = false;
                        draggingCam = false;
                        lastTouchDistance = null;
                    }
                };

                const handleMove = (e) => {
                    if (e.touches && e.touches.length === 2) {
                        // Pinch zoom
                        const [t1, t2] = e.touches;
                        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                        if (lastTouchDistance) {
                            const zoomFactor = dist / lastTouchDistance;
                            const newZoom = this.gridManager.cameraView.zoom * zoomFactor;
                            this.gridManager.cameraView.zoom = Math.max(MAX_ZOOM, Math.min(MIN_ZOOM, newZoom));
                            this.gridManager.drawGrid();
                        }
                        lastTouchDistance = dist;
                        return;
                    }

                    const pointer = getPointer(e);
                    if (painting) {
                        this.toggleAt(pointer.x, pointer.y);
                    }
                    if (draggingCam) {
                        this.gridManager.cameraView.camX += pointer.x - lastX;
                        this.gridManager.cameraView.camY += pointer.y - lastY;
                        lastX = pointer.x;
                        lastY = pointer.y;
                        this.gridManager.drawGrid();
                    }
                };

                const handleUp = () => {
                    painting = false;
                    draggingCam = false;
                    lastTouchDistance = null;
                };

                // Mouse
                this.gridCanvas.addEventListener('mousedown', (e) => handleDown(getPointer(e)));
                this.gridCanvas.addEventListener('mousemove', handleMove);
                this.gridCanvas.addEventListener('mouseup', handleUp);
                this.gridCanvas.addEventListener('mouseleave', handleUp);

                // Touch
                this.gridCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleDown(getPointer(e)); });
                this.gridCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); });
                this.gridCanvas.addEventListener('touchend', handleUp);
                this.gridCanvas.addEventListener('touchcancel', handleUp);

                // Context menu disable
                this.gridCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Wheel zoom
                this.gridCanvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = this.gridManager.cameraView.zoom * zoomFactor;
                    this.gridManager.cameraView.zoom = Math.max(MAX_ZOOM, Math.min(MIN_ZOOM, newZoom));
                    this.gridManager.drawGrid();
                }, { passive: false });

                // Prevent elastic scrolling
                this.gridCanvas.style.touchAction = 'none';
            }

            toggleAt(px, py) {
                this.gridManager.toggleAt(
                    px, py,
                    this.drawTiles.checked,
                    this.eraseTiles.checked,
                    this.gridManager.infiniteGrid,
                );
                this.gridManager.drawGrid();
                // console.log(this.gridManager.cells);
            }

        }

        // Initialize the simulator when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AutomataSimulator();
        });
    </script>

</body>
</html>